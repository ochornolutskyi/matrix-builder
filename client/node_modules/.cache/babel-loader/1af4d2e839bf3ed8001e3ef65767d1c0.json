{"ast":null,"code":"import { INCREMENT_CELL, CREATE_MATRIX, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS, SET_SETTINGS, REBUILD_MATRIX } from \"../types\";\nconst initialState = {\n  settings: {\n    rowsCount: 0,\n    columnsCount: 0,\n    cellsCount: 0\n  },\n  nearestIds: [],\n  data: []\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n  while (step < columnsCount) {\n    row.push({\n      id: String(rowNumber + 1).concat(step + 1),\n      value: Math.round(100 + Math.random() * 899)\n    });\n    step++;\n  }\n\n  return row;\n};\n\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n  while (step < rowsCount) {\n    const rowCells = addCells(data.length, columnsCount);\n    data.push(rowCells);\n    step++;\n  }\n\n  return data;\n};\n\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n  return addRows(data, rowsCount, columnsCount);\n};\n\nconst findNearestIds = (matrixData, cellsCount, id) => {\n  if (+cellsCount === 0) {\n    return [];\n  } else {\n    let nearestIds = [];\n    let sortedMatrix = matrixData.reduce((currentRow, nextRow) => currentRow.concat(nextRow), []).sort((a, b) => a.value - b.value);\n    const iterationCount = cellsCount < sortedMatrix.length ? cellsCount : sortedMatrix.length - 1;\n    let indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n    const exclusionIds = indexCurrentId => sortedMatrix.filter((item, index) => index !== indexCurrentId).forEach(item => nearestIds.push(item.id)); //get ids when the hovered item is the lowest\n\n\n    if (indexCurrentId === 0) {\n      sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(1, iterationCount).forEach(item => nearestIds.push(item.id));\n    } //get ids when the hovered item is the biggest\n    else if (indexCurrentId === sortedMatrix.length - 1) {\n        sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(-iterationCount - 1, iterationCount).forEach(item => nearestIds.push(item.id));\n      } //other options\n      else {\n          if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n          } else {\n            for (let i = 0; i < iterationCount; i++) {\n              indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n              if (indexCurrentId === 0) {\n                sortedMatrix.splice(1, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else if (indexCurrentId === sortedMatrix.length - 1) {\n                const from = -indexCurrentId - iterationCount - i - 1;\n                sortedMatrix.splice(from, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else {\n                const prevItem = sortedMatrix[indexCurrentId - 1];\n                const nextItem = sortedMatrix[indexCurrentId + 1];\n                const currentItem = sortedMatrix[indexCurrentId];\n                const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                nearestIds.push(nearestItem.id);\n                sortedMatrix.splice(sortedMatrix.indexOf(sortedMatrix.find(item => item === nearestItem)), 1);\n              }\n            }\n          }\n        }\n\n    return nearestIds;\n  }\n};\n\nconst rebuildColumns = (data, prevColumnsCount, settedColumnsCount) => {\n  if (data.length !== 0 && prevColumnsCount < settedColumnsCount) {\n    console.log(\"blur\");\n    const columnsCount = settedColumnsCount - prevColumnsCount;\n    return data.forEach((row, index) => addCells(index, columnsCount, row));\n  }\n};\n/* if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount < +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < settings.columnsCount - state.settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item, index) => {\n         const cellObject = {\n            id: String(index + 1).concat(item.length + 1),\n            value: Math.round(100 + Math.random() * 899),\n         };\n         item.push(cellObject);\n      });\n   }\n} else if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount > +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < state.settings.columnsCount - settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item) => {\n         item.pop();\n      });\n      console.log(data);\n   }\n} */\n\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings = { ...state.settings\n  },\n      data = [...state.data],\n      nearestIds;\n\n  switch (action.type) {\n    case SET_SETTINGS:\n      const newSettings = { ...action.settings\n      };\n\n      if (data.length === 0) {\n        data = createMatrix(newSettings.rowsCount, newSettings.columnsCount);\n        settings = newSettings;\n      }\n\n      return { ...state,\n        data,\n        settings\n      };\n\n    /*   case CREATE_MATRIX:\n       return { ...state, data }; */\n\n    case REBUILD_MATRIX:\n      rebuildColumns(data);\n      return { ...state,\n        data\n      };\n\n    case ADD_ROW:\n      addRows(data, 1, settings.columnsCount);\n      settings.rowsCount = data.length;\n      return { ...state,\n        settings,\n        data\n      };\n\n    case REMOVE_ROW:\n      data.splice(action.rowIndex, 1);\n      settings.rowsCount = data.length;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case INCREMENT_CELL:\n      data.find(row => row.find(item => item.id === action.id ? item.value++ : null));\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        data,\n        nearestIds\n      };\n\n    case SET_NEAREST_IDS:\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        nearestIds\n      };\n\n    case RESET_NEAREST_IDS:\n      data = [...state.data];\n      nearestIds = [];\n      return { ...state,\n        nearestIds\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["INCREMENT_CELL","CREATE_MATRIX","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","SET_SETTINGS","REBUILD_MATRIX","initialState","settings","rowsCount","columnsCount","cellsCount","nearestIds","data","addCells","rowNumber","row","step","push","id","String","concat","value","Math","round","random","addRows","rowCells","length","createMatrix","findNearestIds","matrixData","sortedMatrix","reduce","currentRow","nextRow","sort","a","b","iterationCount","indexCurrentId","indexOf","find","item","exclusionIds","filter","index","forEach","splice","i","from","prevItem","nextItem","currentItem","prevDiff","abs","nextDiff","nearestItem","rebuildColumns","prevColumnsCount","settedColumnsCount","console","log","matrixReducer","state","action","type","newSettings","rowIndex"],"mappings":"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","sourcesContent":["import {\n   INCREMENT_CELL,\n   CREATE_MATRIX,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n   SET_SETTINGS,\n   REBUILD_MATRIX,\n} from \"../types\";\n\nconst initialState = {\n   settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n   nearestIds: [],\n   data: [],\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n   while (step < columnsCount) {\n      row.push({\n         id: String(rowNumber + 1).concat(step + 1),\n         value: Math.round(100 + Math.random() * 899),\n      });\n      step++;\n   }\n   return row;\n};\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n   while (step < rowsCount) {\n      const rowCells = addCells(data.length, columnsCount);\n      data.push(rowCells);\n      step++;\n   }\n   return data;\n};\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n   return addRows(data, rowsCount, columnsCount);\n};\nconst findNearestIds = (matrixData, cellsCount, id) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow), [])\n         .sort((a, b) => a.value - b.value);\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentId = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.id === id)\n      );\n      const exclusionIds = (indexCurrentId) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentId)\n            .forEach((item) => nearestIds.push(item.id));\n      //get ids when the hovered item is the lowest\n      if (indexCurrentId === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //get ids when the hovered item is the biggest\n      else if (indexCurrentId === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //other options\n      else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               indexCurrentId = sortedMatrix.indexOf(\n                  sortedMatrix.find((item) => item.id === id)\n               );\n               if (indexCurrentId === 0) {\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentId === sortedMatrix.length - 1) {\n                  const from = -indexCurrentId - iterationCount - i - 1;\n                  sortedMatrix\n                     .splice(from, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  const prevItem = sortedMatrix[indexCurrentId - 1];\n                  const nextItem = sortedMatrix[indexCurrentId + 1];\n                  const currentItem = sortedMatrix[indexCurrentId];\n                  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                  nearestIds.push(nearestItem.id);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item === nearestItem)\n                     ),\n                     1\n                  );\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n};\nconst rebuildColumns = (data, prevColumnsCount, settedColumnsCount) => {\n   if (data.length !== 0 && prevColumnsCount < settedColumnsCount) {\n      console.log(\"blur\");\n\n      const columnsCount = settedColumnsCount - prevColumnsCount;\n      return data.forEach((row, index) => addCells(index, columnsCount, row));\n   }\n};\n/* if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount < +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < settings.columnsCount - state.settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item, index) => {\n         const cellObject = {\n            id: String(index + 1).concat(item.length + 1),\n            value: Math.round(100 + Math.random() * 899),\n         };\n         item.push(cellObject);\n      });\n   }\n} else if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount > +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < state.settings.columnsCount - settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item) => {\n         item.pop();\n      });\n      console.log(data);\n   }\n} */\nconst matrixReducer = (state = initialState, action) => {\n   let settings = { ...state.settings },\n      data = [...state.data],\n      nearestIds;\n   switch (action.type) {\n      case SET_SETTINGS:\n         const newSettings = { ...action.settings };\n         if (data.length === 0) {\n            data = createMatrix(\n               newSettings.rowsCount,\n               newSettings.columnsCount\n            );\n            settings = newSettings;\n         }\n         return { ...state, data, settings };\n\n      /*   case CREATE_MATRIX:\n         return { ...state, data }; */\n      case REBUILD_MATRIX:\n         rebuildColumns(data);\n         return { ...state, data };\n      case ADD_ROW:\n         addRows(data, 1, settings.columnsCount);\n         settings.rowsCount = data.length;\n         return { ...state, settings, data };\n      case REMOVE_ROW:\n         data.splice(action.rowIndex, 1);\n         settings.rowsCount = data.length;\n         return { ...state, data, settings };\n      case INCREMENT_CELL:\n         data.find((row) =>\n            row.find((item) => (item.id === action.id ? item.value++ : null))\n         );\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, data, nearestIds };\n      case SET_NEAREST_IDS:\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, nearestIds };\n      case RESET_NEAREST_IDS:\n         data = [...state.data];\n         nearestIds = [];\n         return { ...state, nearestIds };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}