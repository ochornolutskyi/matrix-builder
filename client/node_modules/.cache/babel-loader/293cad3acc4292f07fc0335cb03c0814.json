{"ast":null,"code":"import { INCREMENT_CELL, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS, SET_SETTINGS } from \"../types\";\nconst initialState = {\n  settings: {\n    rowsCount: 0,\n    columnsCount: 0,\n    cellsCount: 0\n  },\n  nearestIds: [],\n  data: []\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n  while (step < columnsCount) {\n    row.push({\n      id: String(rowNumber + 1).concat(row.length + 1),\n      value: Math.round(100 + Math.random() * 899)\n    });\n    step++;\n  }\n\n  return row;\n};\n\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n  while (step < rowsCount) {\n    const rowCells = addCells(data.length, columnsCount);\n    data.push(rowCells);\n    step++;\n  }\n\n  return data;\n};\n\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n  return addRows(data, rowsCount, columnsCount);\n};\n\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n  const rebuildColumns = () => {\n    let columnsCountDiff = 0;\n\n    if (prevSettings.columnsCount < newSettings.columnsCount) {\n      columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n      data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n    } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n      columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n      data.forEach(row => row.splice(-columnsCountDiff));\n    }\n\n    return data;\n  };\n\n  const rebuildRows = () => {\n    let rowsCountDiff = 0;\n\n    if (prevSettings.rowsCount < newSettings.rowsCount) {\n      rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n      addRows(data, rowsCountDiff, newSettings.columnsCount);\n    } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n      rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n      data.splice(-rowsCountDiff);\n    }\n\n    return data;\n  };\n\n  rebuildColumns(data, prevSettings, newSettings);\n  rebuildRows(data, prevSettings, newSettings);\n  return data;\n};\n\nconst findNearestIds = (data, cellsCount, targetId) => {\n  if (cellsCount === 0) {\n    return [];\n  } else {\n    let nearestIds = [];\n    let allMatrixData = data.flat();\n    const targetValue = allMatrixData.find(item => item.id === targetId).value; // const sameValueIds = \n    // let indexCurrentId = allMatrixData.indexOf(\n    //    allMatrixData.find((item) => item.id === targetId)\n    // );\n    // const sortedValues = allMatrixData.map((cell) => cell.value).sort();\n\n    console.log(sortedValues);\n    return nearestIds;\n  }\n};\n/* const findNearestIds = (matrixData, cellsCount, id) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow), [])\n         .sort((a, b) => a.value - b.value);\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentId = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.id === id)\n      );\n      const exclusionIds = (indexCurrentId) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentId)\n            .forEach((item) => nearestIds.push(item.id));\n      //get ids when the hovered item is the lowest\n      if (indexCurrentId === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //get ids when the hovered item is the biggest\n      else if (indexCurrentId === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //other options\n      else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               indexCurrentId = sortedMatrix.indexOf(\n                  sortedMatrix.find((item) => item.id === id)\n               );\n               if (indexCurrentId === 0) {\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentId === sortedMatrix.length - 1) {\n                  const from = -indexCurrentId - iterationCount - i - 1;\n                  sortedMatrix\n                     .splice(from, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  const prevItem = sortedMatrix[indexCurrentId - 1];\n                  const nextItem = sortedMatrix[indexCurrentId + 1];\n                  const currentItem = sortedMatrix[indexCurrentId];\n                  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                  nearestIds.push(nearestItem.id);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item === nearestItem)\n                     ),\n                     1\n                  );\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n}; */\n\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings = { ...state.settings\n  },\n      data = [...state.data],\n      nearestIds;\n\n  switch (action.type) {\n    case SET_SETTINGS:\n      const newSettings = { ...action.settings\n      };\n\n      if (data.length === 0) {\n        data = createMatrix(newSettings.rowsCount, newSettings.columnsCount);\n      } else if (settings.rowsCount !== newSettings.rowsCount || settings.columnsCount !== newSettings.columnsCount) {\n        rebuildMatrix(data, settings, newSettings);\n      }\n\n      settings = newSettings;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case ADD_ROW:\n      addRows(data, 1, settings.columnsCount);\n      settings.rowsCount = data.length;\n      return { ...state,\n        settings,\n        data\n      };\n\n    case REMOVE_ROW:\n      data.splice(action.rowIndex, 1);\n      settings.rowsCount = data.length;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case INCREMENT_CELL:\n      data.find(row => row.find(item => item.id === action.id ? item.value++ : null)); // nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n\n      return { ...state,\n        data,\n        nearestIds\n      };\n\n    case SET_NEAREST_IDS:\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        nearestIds\n      };\n\n    case RESET_NEAREST_IDS:\n      data = [...state.data];\n      nearestIds = [];\n      return { ...state,\n        nearestIds\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["INCREMENT_CELL","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","SET_SETTINGS","initialState","settings","rowsCount","columnsCount","cellsCount","nearestIds","data","addCells","rowNumber","row","step","push","id","String","concat","length","value","Math","round","random","addRows","rowCells","createMatrix","rebuildMatrix","prevSettings","newSettings","rebuildColumns","columnsCountDiff","forEach","index","splice","rebuildRows","rowsCountDiff","findNearestIds","targetId","allMatrixData","flat","targetValue","find","item","console","log","sortedValues","matrixReducer","state","action","type","rowIndex"],"mappings":"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","sourcesContent":["import {\n   INCREMENT_CELL,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n   SET_SETTINGS,\n} from \"../types\";\n\nconst initialState = {\n   settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n   nearestIds: [],\n   data: [],\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n   while (step < columnsCount) {\n      row.push({\n         id: String(rowNumber + 1).concat(row.length + 1),\n         value: Math.round(100 + Math.random() * 899),\n      });\n      step++;\n   }\n   return row;\n};\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n   while (step < rowsCount) {\n      const rowCells = addCells(data.length, columnsCount);\n      data.push(rowCells);\n      step++;\n   }\n   return data;\n};\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n   return addRows(data, rowsCount, columnsCount);\n};\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n   const rebuildColumns = () => {\n      let columnsCountDiff = 0;\n      if (prevSettings.columnsCount < newSettings.columnsCount) {\n         columnsCountDiff =\n            newSettings.columnsCount - prevSettings.columnsCount;\n         data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n      } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n         columnsCountDiff =\n            prevSettings.columnsCount - newSettings.columnsCount;\n         data.forEach((row) => row.splice(-columnsCountDiff));\n      }\n      return data;\n   };\n   const rebuildRows = () => {\n      let rowsCountDiff = 0;\n      if (prevSettings.rowsCount < newSettings.rowsCount) {\n         rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n         addRows(data, rowsCountDiff, newSettings.columnsCount);\n      } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n         rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n         data.splice(-rowsCountDiff);\n      }\n      return data;\n   };\n   rebuildColumns(data, prevSettings, newSettings);\n   rebuildRows(data, prevSettings, newSettings);\n   return data;\n};\nconst findNearestIds = (data, cellsCount, targetId) => {\n   if (cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let allMatrixData = data.flat();\n      const targetValue = allMatrixData.find(item => item.id === targetId).value\n      // const sameValueIds = \n      // let indexCurrentId = allMatrixData.indexOf(\n      //    allMatrixData.find((item) => item.id === targetId)\n      // );\n      // const sortedValues = allMatrixData.map((cell) => cell.value).sort();\n      console.log(sortedValues);\n      return nearestIds;\n   }\n};\n/* const findNearestIds = (matrixData, cellsCount, id) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow), [])\n         .sort((a, b) => a.value - b.value);\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentId = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.id === id)\n      );\n      const exclusionIds = (indexCurrentId) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentId)\n            .forEach((item) => nearestIds.push(item.id));\n      //get ids when the hovered item is the lowest\n      if (indexCurrentId === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //get ids when the hovered item is the biggest\n      else if (indexCurrentId === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //other options\n      else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               indexCurrentId = sortedMatrix.indexOf(\n                  sortedMatrix.find((item) => item.id === id)\n               );\n               if (indexCurrentId === 0) {\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentId === sortedMatrix.length - 1) {\n                  const from = -indexCurrentId - iterationCount - i - 1;\n                  sortedMatrix\n                     .splice(from, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  const prevItem = sortedMatrix[indexCurrentId - 1];\n                  const nextItem = sortedMatrix[indexCurrentId + 1];\n                  const currentItem = sortedMatrix[indexCurrentId];\n                  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                  nearestIds.push(nearestItem.id);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item === nearestItem)\n                     ),\n                     1\n                  );\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n}; */\n\nconst matrixReducer = (state = initialState, action) => {\n   let settings = { ...state.settings },\n      data = [...state.data],\n      nearestIds;\n   switch (action.type) {\n      case SET_SETTINGS:\n         const newSettings = { ...action.settings };\n         if (data.length === 0) {\n            data = createMatrix(\n               newSettings.rowsCount,\n               newSettings.columnsCount\n            );\n         } else if (\n            settings.rowsCount !== newSettings.rowsCount ||\n            settings.columnsCount !== newSettings.columnsCount\n         ) {\n            rebuildMatrix(data, settings, newSettings);\n         }\n         settings = newSettings;\n         return { ...state, data, settings };\n      case ADD_ROW:\n         addRows(data, 1, settings.columnsCount);\n         settings.rowsCount = data.length;\n         return { ...state, settings, data };\n      case REMOVE_ROW:\n         data.splice(action.rowIndex, 1);\n         settings.rowsCount = data.length;\n         return { ...state, data, settings };\n      case INCREMENT_CELL:\n         data.find((row) =>\n            row.find((item) => (item.id === action.id ? item.value++ : null))\n         );\n         // nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, data, nearestIds };\n      case SET_NEAREST_IDS:\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, nearestIds };\n      case RESET_NEAREST_IDS:\n         data = [...state.data];\n         nearestIds = [];\n         return { ...state, nearestIds };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}