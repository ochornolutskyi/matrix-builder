{"ast":null,"code":"const calculateAverageValues = matrixData => {\n  let averageValues = [];\n\n  for (let i = 0; i < rowsValues[i].length; i++) {\n    const columnValues = rowsValues.map(row => row[i]).reduce((sum, value) => sum + value, 0);\n    const average = columnValues / matrixData.length;\n    averageValues.push(average);\n  }\n\n  return averageValues;\n};\n\nexport default calculateAverageValues; //current row values and next row values return the sum of values by equal index\n\n/*   values\n      .reduce((currentRow, nextRow) =>\n         currentRow.map((value, index) => value + nextRow[index])\n      )\n      .map((value) => value / data.length); */","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/components/Main/Table/TableBody/AverageRow/calculateAverageValues.js"],"names":["calculateAverageValues","matrixData","averageValues","i","rowsValues","length","columnValues","map","row","reduce","sum","value","average","push"],"mappings":"AAAA,MAAMA,sBAAsB,GAAIC,UAAD,IAAgB;AAC5C,MAAIC,aAAa,GAAG,EAApB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,UAAU,CAACD,CAAD,CAAV,CAAcE,MAAlC,EAA0CF,CAAC,EAA3C,EAA+C;AAC5C,UAAMG,YAAY,GAAGF,UAAU,CAC3BG,GADiB,CACZC,GAAD,IAASA,GAAG,CAACL,CAAD,CADC,EAEjBM,MAFiB,CAEV,CAACC,GAAD,EAAMC,KAAN,KAAgBD,GAAG,GAAGC,KAFZ,EAEmB,CAFnB,CAArB;AAGA,UAAMC,OAAO,GAAGN,YAAY,GAAGL,UAAU,CAACI,MAA1C;AACAH,IAAAA,aAAa,CAACW,IAAd,CAAmBD,OAAnB;AACF;;AACD,SAAOV,aAAP;AACF,CAVD;;AAWA,eAAeF,sBAAf,C,CACA;;AACA","sourcesContent":["const calculateAverageValues = (matrixData) => {\n   let averageValues = [];\n   for (let i = 0; i < rowsValues[i].length; i++) {\n      const columnValues = rowsValues\n         .map((row) => row[i])\n         .reduce((sum, value) => sum + value, 0);\n      const average = columnValues / matrixData.length;\n      averageValues.push(average);\n   }\n   return averageValues;\n};\nexport default calculateAverageValues;\n//current row values and next row values return the sum of values by equal index\n/*   values\n      .reduce((currentRow, nextRow) =>\n         currentRow.map((value, index) => value + nextRow[index])\n      )\n      .map((value) => value / data.length); */\n"]},"metadata":{},"sourceType":"module"}