{"ast":null,"code":"import { INCREMENT_CELL, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS, SET_SETTINGS } from \"../types\";\nconst initialState = {\n  settings: {\n    rowsCount: 0,\n    columnsCount: 0,\n    cellsCount: 0\n  },\n  nearestIds: [],\n  data: []\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n  while (step < columnsCount) {\n    row.push({\n      id: String(rowNumber + 1).concat(row.length + 1),\n      value: Math.round(100 + Math.random() * 899)\n    });\n    step++;\n  }\n\n  return row;\n};\n/* const removeCells = (row, columnsCount, step) => {\n   while (step < columnsCount) {\n      row.pop();\n   }\n}; */\n\n\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n  while (step < rowsCount) {\n    const rowCells = addCells(data.length, columnsCount);\n    data.push(rowCells);\n    step++;\n  }\n\n  return data;\n};\n\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n  return addRows(data, rowsCount, columnsCount);\n};\n\nconst findNearestIds = (matrixData, cellsCount, id) => {\n  if (+cellsCount === 0) {\n    return [];\n  } else {\n    let nearestIds = [];\n    let sortedMatrix = matrixData.reduce((currentRow, nextRow) => currentRow.concat(nextRow), []).sort((a, b) => a.value - b.value);\n    const iterationCount = cellsCount < sortedMatrix.length ? cellsCount : sortedMatrix.length - 1;\n    let indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n    const exclusionIds = indexCurrentId => sortedMatrix.filter((item, index) => index !== indexCurrentId).forEach(item => nearestIds.push(item.id)); //get ids when the hovered item is the lowest\n\n\n    if (indexCurrentId === 0) {\n      sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(1, iterationCount).forEach(item => nearestIds.push(item.id));\n    } //get ids when the hovered item is the biggest\n    else if (indexCurrentId === sortedMatrix.length - 1) {\n        sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(-iterationCount - 1, iterationCount).forEach(item => nearestIds.push(item.id));\n      } //other options\n      else {\n          if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n          } else {\n            for (let i = 0; i < iterationCount; i++) {\n              indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n              if (indexCurrentId === 0) {\n                sortedMatrix.splice(1, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else if (indexCurrentId === sortedMatrix.length - 1) {\n                const from = -indexCurrentId - iterationCount - i - 1;\n                sortedMatrix.splice(from, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else {\n                const prevItem = sortedMatrix[indexCurrentId - 1];\n                const nextItem = sortedMatrix[indexCurrentId + 1];\n                const currentItem = sortedMatrix[indexCurrentId];\n                const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                nearestIds.push(nearestItem.id);\n                sortedMatrix.splice(sortedMatrix.indexOf(sortedMatrix.find(item => item === nearestItem)), 1);\n              }\n            }\n          }\n        }\n\n    return nearestIds;\n  }\n};\n\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n  let columnsCountDiff = null;\n\n  if (prevSettings.columnsCount < newSettings.columnsCount) {\n    columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n    data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n  } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n    columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n    data.forEach(row => row.splice(-columnsCountDiff));\n  }\n\n  return data;\n};\n/* if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount < +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < settings.columnsCount - state.settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item, index) => {\n         const cellObject = {\n            id: String(index + 1).concat(item.length + 1),\n            value: Math.round(100 + Math.random() * 899),\n         };\n         item.push(cellObject);\n      });\n   }\n} else if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount > +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < state.settings.columnsCount - settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item) => {\n         item.pop();\n      });\n      console.log(data);\n   }\n} */\n\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings = { ...state.settings\n  },\n      data = [...state.data],\n      nearestIds;\n\n  switch (action.type) {\n    case SET_SETTINGS:\n      const newSettings = { ...action.settings\n      };\n\n      if (data.length === 0) {\n        data = createMatrix(newSettings.rowsCount, newSettings.columnsCount);\n      } else if (settings.rowsCount !== newSettings.rowsCount || settings.columnsCount !== newSettings.columnsCount) {\n        rebuildMatrix(data, settings, newSettings);\n      } else if (settings.cellsCount !== newSettings.cellsCount) {}\n\n      settings = newSettings;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case ADD_ROW:\n      addRows(data, 1, settings.columnsCount);\n      settings.rowsCount = data.length;\n      return { ...state,\n        settings,\n        data\n      };\n\n    case REMOVE_ROW:\n      data.splice(action.rowIndex, 1);\n      settings.rowsCount = data.length;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case INCREMENT_CELL:\n      data.find(row => row.find(item => item.id === action.id ? item.value++ : null));\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        data,\n        nearestIds\n      };\n\n    case SET_NEAREST_IDS:\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        nearestIds\n      };\n\n    case RESET_NEAREST_IDS:\n      data = [...state.data];\n      nearestIds = [];\n      return { ...state,\n        nearestIds\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["INCREMENT_CELL","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","SET_SETTINGS","initialState","settings","rowsCount","columnsCount","cellsCount","nearestIds","data","addCells","rowNumber","row","step","push","id","String","concat","length","value","Math","round","random","addRows","rowCells","createMatrix","findNearestIds","matrixData","sortedMatrix","reduce","currentRow","nextRow","sort","a","b","iterationCount","indexCurrentId","indexOf","find","item","exclusionIds","filter","index","forEach","splice","i","from","prevItem","nextItem","currentItem","prevDiff","abs","nextDiff","nearestItem","rebuildMatrix","prevSettings","newSettings","columnsCountDiff","matrixReducer","state","action","type","rowIndex"],"mappings":"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","sourcesContent":["import {\n   INCREMENT_CELL,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n   SET_SETTINGS,\n} from \"../types\";\n\nconst initialState = {\n   settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n   nearestIds: [],\n   data: [],\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n   while (step < columnsCount) {\n      row.push({\n         id: String(rowNumber + 1).concat(row.length + 1),\n         value: Math.round(100 + Math.random() * 899),\n      });\n      step++;\n   }\n   return row;\n};\n/* const removeCells = (row, columnsCount, step) => {\n   while (step < columnsCount) {\n      row.pop();\n   }\n}; */\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n   while (step < rowsCount) {\n      const rowCells = addCells(data.length, columnsCount);\n      data.push(rowCells);\n      step++;\n   }\n   return data;\n};\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n   return addRows(data, rowsCount, columnsCount);\n};\nconst findNearestIds = (matrixData, cellsCount, id) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow), [])\n         .sort((a, b) => a.value - b.value);\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentId = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.id === id)\n      );\n      const exclusionIds = (indexCurrentId) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentId)\n            .forEach((item) => nearestIds.push(item.id));\n      //get ids when the hovered item is the lowest\n      if (indexCurrentId === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //get ids when the hovered item is the biggest\n      else if (indexCurrentId === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //other options\n      else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               indexCurrentId = sortedMatrix.indexOf(\n                  sortedMatrix.find((item) => item.id === id)\n               );\n               if (indexCurrentId === 0) {\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentId === sortedMatrix.length - 1) {\n                  const from = -indexCurrentId - iterationCount - i - 1;\n                  sortedMatrix\n                     .splice(from, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  const prevItem = sortedMatrix[indexCurrentId - 1];\n                  const nextItem = sortedMatrix[indexCurrentId + 1];\n                  const currentItem = sortedMatrix[indexCurrentId];\n                  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                  nearestIds.push(nearestItem.id);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item === nearestItem)\n                     ),\n                     1\n                  );\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n};\n\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n   let columnsCountDiff = null;\n   if (prevSettings.columnsCount < newSettings.columnsCount) {\n      columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n      data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n   } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n      columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n      data.forEach((row) => row.splice(-columnsCountDiff));\n   }\n   return data;\n};\n/* if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount < +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < settings.columnsCount - state.settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item, index) => {\n         const cellObject = {\n            id: String(index + 1).concat(item.length + 1),\n            value: Math.round(100 + Math.random() * 899),\n         };\n         item.push(cellObject);\n      });\n   }\n} else if (\n   state.data.length !== 0 &&\n   state.settings.columnsCount > +settings.columnsCount\n) {\n   for (\n      let i = 0;\n      i < state.settings.columnsCount - settings.columnsCount;\n      i++\n   ) {\n      data.forEach((item) => {\n         item.pop();\n      });\n      console.log(data);\n   }\n} */\nconst matrixReducer = (state = initialState, action) => {\n   let settings = { ...state.settings },\n      data = [...state.data],\n      nearestIds;\n   switch (action.type) {\n      case SET_SETTINGS:\n         const newSettings = { ...action.settings };\n         if (data.length === 0) {\n            data = createMatrix(\n               newSettings.rowsCount,\n               newSettings.columnsCount\n            );\n         } else if (\n            settings.rowsCount !== newSettings.rowsCount ||\n            settings.columnsCount !== newSettings.columnsCount\n         ) {\n            rebuildMatrix(data, settings, newSettings);\n         } else if (settings.cellsCount !== newSettings.cellsCount) {\n         }\n         settings = newSettings;\n         return { ...state, data, settings };\n      case ADD_ROW:\n         addRows(data, 1, settings.columnsCount);\n         settings.rowsCount = data.length;\n         return { ...state, settings, data };\n      case REMOVE_ROW:\n         data.splice(action.rowIndex, 1);\n         settings.rowsCount = data.length;\n         return { ...state, data, settings };\n      case INCREMENT_CELL:\n         data.find((row) =>\n            row.find((item) => (item.id === action.id ? item.value++ : null))\n         );\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, data, nearestIds };\n      case SET_NEAREST_IDS:\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, nearestIds };\n      case RESET_NEAREST_IDS:\n         data = [...state.data];\n         nearestIds = [];\n         return { ...state, nearestIds };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}