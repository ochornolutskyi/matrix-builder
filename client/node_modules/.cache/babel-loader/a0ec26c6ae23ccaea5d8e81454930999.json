{"ast":null,"code":"import { INCREMENT_CELL, CREATE_MATRIX, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS, SET_SETTINGS } from \"../types\";\nconst initialState = {\n  settings: {\n    rowsCount: 0,\n    columnsCount: 0,\n    cellsCount: 0\n  },\n  nearestIds: [],\n  data: []\n};\n\nconst findNearestIds = (matrixData, cellsCount, id) => {\n  if (+cellsCount === 0) {\n    return [];\n  } else {\n    let nearestIds = [];\n    let sortedMatrix = matrixData.reduce((currentRow, nextRow) => currentRow.concat(nextRow), []).sort((a, b) => a.value - b.value);\n    const iterationCount = cellsCount < sortedMatrix.length ? cellsCount : sortedMatrix.length - 1;\n    let indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n    const exclusionIds = indexCurrentId => sortedMatrix.filter((item, index) => index !== indexCurrentId).forEach(item => nearestIds.push(item.id)); //get ids when the hovered item is the lowest\n\n\n    if (indexCurrentId === 0) {\n      sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(1, iterationCount).forEach(item => nearestIds.push(item.id));\n    } //get ids when the hovered item is the biggest\n    else if (indexCurrentId === sortedMatrix.length - 1) {\n        sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(-iterationCount - 1, iterationCount).forEach(item => nearestIds.push(item.id));\n      } //other options\n      else {\n          if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n          } else {\n            for (let i = 0; i < iterationCount; i++) {\n              indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n              if (indexCurrentId === 0) {\n                sortedMatrix.splice(1, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else if (indexCurrentId === sortedMatrix.length - 1) {\n                const from = -indexCurrentId - iterationCount - i - 1;\n                sortedMatrix.splice(from, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else {\n                const prevItem = sortedMatrix[indexCurrentId - 1];\n                const nextItem = sortedMatrix[indexCurrentId + 1];\n                const currentItem = sortedMatrix[indexCurrentId];\n                const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                nearestIds.push(nearestItem.id);\n                sortedMatrix.splice(sortedMatrix.indexOf(sortedMatrix.find(item => item === nearestItem)), 1);\n              }\n            }\n          }\n        }\n\n    return nearestIds;\n  }\n};\n\nconst addCells = (data, columnsCount, step = 0) => {\n  while (step < columnsCount) {\n    const id = \"\";\n    const value = Math.round(100 + Math.random() * 899);\n    data.forEach((item, index) => {\n      const cellData = {\n        id: String(data.length + 1).concat(item.length + 1),\n        value: Math.round(100 + Math.random() * 899)\n      };\n      item.push(cellData);\n      step++;\n    });\n  }\n\n  return data;\n};\n\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n  while (step < rowsCount) {\n    data.push([]);\n    addCells(data, columnsCount);\n    step++;\n  }\n\n  return data;\n}; // const test = addRows([], 3, 5);\n// console.log(test);\n\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings,\n      data,\n      nearestIds,\n      cellsCount = state.settings.cellsCount;\n\n  switch (action.type) {\n    case SET_SETTINGS:\n      data = [...state.data];\n      settings = { ...action.settings\n      };\n\n      if (state.data.length !== 0 && state.settings.columnsCount < +settings.columnsCount) {\n        for (let i = 0; i < settings.columnsCount - state.settings.columnsCount; i++) {\n          data.forEach((item, index) => {\n            const cellObject = {\n              id: String(index + 1).concat(item.length + 1),\n              value: Math.round(100 + Math.random() * 899)\n            };\n            item.push(cellObject);\n          });\n        }\n      } else if (state.data.length !== 0 && state.settings.columnsCount > +settings.columnsCount) {\n        for (let i = 0; i < state.settings.columnsCount - settings.columnsCount; i++) {\n          data.forEach(item => {\n            item.pop();\n          });\n          console.log(data);\n        }\n      }\n\n      return { ...state,\n        data,\n        settings\n      };\n\n    case CREATE_MATRIX:\n      data = [...state.data];\n      settings = { ...state.settings\n      };\n\n      for (let i = 0; i < settings.rowsCount; i++) {\n        const cells = [];\n\n        for (let i = 0; i < settings.columnsCount; i++) {\n          const cellObject = {\n            id: String(data.length + 1).concat(i + 1),\n            value: Math.round(100 + Math.random() * 899)\n          };\n          cells.push(cellObject);\n        }\n\n        data.push(cells);\n      }\n\n      return { ...state,\n        data\n      };\n\n    case INCREMENT_CELL:\n      data = [...state.data];\n      data.find(row => row.find(item => item.id === action.id)).filter(item => item.id === action.id)[0].value++;\n      nearestIds = findNearestIds(data, cellsCount, action.id);\n      return { ...state,\n        data,\n        nearestIds\n      };\n\n    case REMOVE_ROW:\n      data = [...state.data];\n      settings = { ...state.settings\n      };\n      data.splice(action.index, 1);\n      settings.rowsCount = data.length;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case ADD_ROW:\n      data = [...state.data];\n      settings = { ...state.settings\n      };\n      let newRow = [];\n\n      for (let i = 0; i < settings.columnsCount; i++) {\n        const cellObject = {\n          id: String(data.length + 1).concat(i + 1),\n          value: Math.round(100 + Math.random() * 899)\n        };\n        newRow.push(cellObject);\n      }\n\n      data.push(newRow);\n      settings.rowsCount = data.length;\n      return { ...state,\n        settings,\n        data\n      };\n\n    case SET_NEAREST_IDS:\n      data = [...state.data];\n      nearestIds = findNearestIds(data, cellsCount, action.id);\n      return { ...state,\n        nearestIds\n      };\n\n    case RESET_NEAREST_IDS:\n      data = [...state.data];\n      nearestIds = [];\n      return { ...state,\n        nearestIds\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["INCREMENT_CELL","CREATE_MATRIX","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","SET_SETTINGS","initialState","settings","rowsCount","columnsCount","cellsCount","nearestIds","data","findNearestIds","matrixData","id","sortedMatrix","reduce","currentRow","nextRow","concat","sort","a","b","value","iterationCount","length","indexCurrentId","indexOf","find","item","exclusionIds","filter","index","forEach","push","splice","i","from","prevItem","nextItem","currentItem","prevDiff","Math","abs","nextDiff","nearestItem","addCells","step","round","random","cellData","String","addRows","matrixReducer","state","action","type","cellObject","pop","console","log","cells","row","newRow"],"mappings":"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","sourcesContent":["import {\n   INCREMENT_CELL,\n   CREATE_MATRIX,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n   SET_SETTINGS,\n} from \"../types\";\n\nconst initialState = {\n   settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n   nearestIds: [],\n   data: [],\n};\n\nconst findNearestIds = (matrixData, cellsCount, id) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow), [])\n         .sort((a, b) => a.value - b.value);\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentId = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.id === id)\n      );\n      const exclusionIds = (indexCurrentId) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentId)\n            .forEach((item) => nearestIds.push(item.id));\n      //get ids when the hovered item is the lowest\n      if (indexCurrentId === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //get ids when the hovered item is the biggest\n      else if (indexCurrentId === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //other options\n      else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               indexCurrentId = sortedMatrix.indexOf(\n                  sortedMatrix.find((item) => item.id === id)\n               );\n               if (indexCurrentId === 0) {\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentId === sortedMatrix.length - 1) {\n                  const from = -indexCurrentId - iterationCount - i - 1;\n                  sortedMatrix\n                     .splice(from, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  const prevItem = sortedMatrix[indexCurrentId - 1];\n                  const nextItem = sortedMatrix[indexCurrentId + 1];\n                  const currentItem = sortedMatrix[indexCurrentId];\n                  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                  nearestIds.push(nearestItem.id);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item === nearestItem)\n                     ),\n                     1\n                  );\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n};\n\nconst addCells = (data, columnsCount, step = 0) => {\n   while (step < columnsCount) {\n      const id = \"\";\n      const value = Math.round(100 + Math.random() * 899);\n      data.forEach((item, index) => {\n         const cellData = {\n            id: String(data.length + 1).concat(item.length + 1),\n            value: Math.round(100 + Math.random() * 899),\n         };\n         item.push(cellData);\n         step++;\n      });\n   }\n   return data;\n};\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n   while (step < rowsCount) {\n      data.push([]);\n      addCells(data, columnsCount);\n      step++;\n   }\n   return data;\n};\n// const test = addRows([], 3, 5);\n// console.log(test);\nconst matrixReducer = (state = initialState, action) => {\n   let settings,\n      data,\n      nearestIds,\n      cellsCount = state.settings.cellsCount;\n   switch (action.type) {\n      case SET_SETTINGS:\n         data = [...state.data];\n         settings = { ...action.settings };\n         if (\n            state.data.length !== 0 &&\n            state.settings.columnsCount < +settings.columnsCount\n         ) {\n            for (\n               let i = 0;\n               i < settings.columnsCount - state.settings.columnsCount;\n               i++\n            ) {\n               data.forEach((item, index) => {\n                  const cellObject = {\n                     id: String(index + 1).concat(item.length + 1),\n                     value: Math.round(100 + Math.random() * 899),\n                  };\n                  item.push(cellObject);\n               });\n            }\n         } else if (\n            state.data.length !== 0 &&\n            state.settings.columnsCount > +settings.columnsCount\n         ) {\n            for (\n               let i = 0;\n               i < state.settings.columnsCount - settings.columnsCount;\n               i++\n            ) {\n               data.forEach((item) => {\n                  item.pop();\n               });\n               console.log(data);\n            }\n         }\n         return { ...state, data, settings };\n      case CREATE_MATRIX:\n         data = [...state.data];\n         settings = { ...state.settings };\n         for (let i = 0; i < settings.rowsCount; i++) {\n            const cells = [];\n            for (let i = 0; i < settings.columnsCount; i++) {\n               const cellObject = {\n                  id: String(data.length + 1).concat(i + 1),\n                  value: Math.round(100 + Math.random() * 899),\n               };\n               cells.push(cellObject);\n            }\n            data.push(cells);\n         }\n         return { ...state, data };\n      case INCREMENT_CELL:\n         data = [...state.data];\n         data\n            .find((row) => row.find((item) => item.id === action.id))\n            .filter((item) => item.id === action.id)[0].value++;\n         nearestIds = findNearestIds(data, cellsCount, action.id);\n         return { ...state, data, nearestIds };\n      case REMOVE_ROW:\n         data = [...state.data];\n         settings = { ...state.settings };\n         data.splice(action.index, 1);\n         settings.rowsCount = data.length;\n         return { ...state, data, settings };\n      case ADD_ROW:\n         data = [...state.data];\n         settings = { ...state.settings };\n         let newRow = [];\n         for (let i = 0; i < settings.columnsCount; i++) {\n            const cellObject = {\n               id: String(data.length + 1).concat(i + 1),\n               value: Math.round(100 + Math.random() * 899),\n            };\n            newRow.push(cellObject);\n         }\n         data.push(newRow);\n         settings.rowsCount = data.length;\n         return { ...state, settings, data };\n      case SET_NEAREST_IDS:\n         data = [...state.data];\n         nearestIds = findNearestIds(data, cellsCount, action.id);\n         return { ...state, nearestIds };\n      case RESET_NEAREST_IDS:\n         data = [...state.data];\n         nearestIds = [];\n         return { ...state, nearestIds };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}