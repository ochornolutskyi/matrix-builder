{"ast":null,"code":"const checkTargetValueIsLowest = (sortedData, targetId) => {\n  if (sortedData.indexOf(sortedData.find(item => item.id === targetId)) === 0) {\n    return true;\n  }\n};\n\nconst checkTargetValueIsBiggest = (sortedData, targetId) => {\n  if (sortedData.indexOf(sortedData.find(item => item.id === targetId)) === sortedData.length - 1) {\n    return true;\n  }\n};\n\nconst getNearestIdsOfLowestValue = (sortedData, cellsCount) => {\n  return sortedData.slice(1, cellsCount + 1).map(item => item.id);\n};\n\nconst getNearestIdsOfBiggestValue = (sortedData, cellsCount) => {\n  return sortedData.slice(-cellsCount - 1, -1).map(item => item.id);\n};\n\nconst getNearestId = (sortedData, targetId) => {\n  const indexOfTargetId = sortedData.indexOf(sortedData.find(item => item.id === targetId));\n  const prevItem = sortedData[indexOfTargetId - 1];\n  const nextItem = sortedData[indexOfTargetId + 1];\n  const currentItem = sortedData[indexOfTargetId];\n  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n  return nearestItem.id;\n};\n\nconst findNearestIds = (sortedData, targetId, cellsCount, ids = [], step = 0) => {\n  if (step < cellsCount) {\n    if (checkTargetValueIsLowest(sortedData, targetId)) {\n      ids.push(getNearestIdsOfLowestValue(sortedData, cellsCount - step));\n      return ids.flat();\n    } else if (checkTargetValueIsBiggest(sortedData, targetId)) {\n      ids.push(getNearestIdsOfBiggestValue(sortedData, cellsCount - step));\n      return ids.flat();\n    } else {\n      const id = getNearestId(sortedData, targetId);\n      ids.push(id);\n      sortedData = sortedData.filter(item => item.id !== id);\n      step++;\n      return findNearestIds(sortedData, targetId, cellsCount, ids, step);\n    }\n  }\n\n  return ids;\n};\n\nconst getIds = (sortedData, cellsCount, targetId) => {\n  const targetValue = sortedData.find(item => item.id === targetId).value;\n  const sameValueIds = sortedData.filter(item => item.value === targetValue && item.id !== targetId).map(item => item.id);\n\n  if (sameValueIds.length > 0) {\n    sortedData = sortedData.filter(item => !sameValueIds.includes(item.id));\n  }\n\n  const nearestIds = findNearestIds(sortedData, targetId, cellsCount);\n  return {\n    sameValueIds,\n    ids: nearestIds\n  };\n};\n\nexport default getIds;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer/findNearestIds.js"],"names":["checkTargetValueIsLowest","sortedData","targetId","indexOf","find","item","id","checkTargetValueIsBiggest","length","getNearestIdsOfLowestValue","cellsCount","slice","map","getNearestIdsOfBiggestValue","getNearestId","indexOfTargetId","prevItem","nextItem","currentItem","prevDiff","Math","abs","value","nextDiff","nearestItem","findNearestIds","ids","step","push","flat","filter","getIds","targetValue","sameValueIds","includes","nearestIds"],"mappings":"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","sourcesContent":["const checkTargetValueIsLowest = (sortedData, targetId) => {\n   if (\n      sortedData.indexOf(sortedData.find((item) => item.id === targetId)) === 0\n   ) {\n      return true;\n   }\n};\nconst checkTargetValueIsBiggest = (sortedData, targetId) => {\n   if (\n      sortedData.indexOf(sortedData.find((item) => item.id === targetId)) ===\n      sortedData.length - 1\n   ) {\n      return true;\n   }\n};\nconst getNearestIdsOfLowestValue = (sortedData, cellsCount) => {\n   return sortedData.slice(1, cellsCount + 1).map((item) => item.id);\n};\nconst getNearestIdsOfBiggestValue = (sortedData, cellsCount) => {\n   return sortedData.slice(-cellsCount - 1, -1).map((item) => item.id);\n};\nconst getNearestId = (sortedData, targetId) => {\n   const indexOfTargetId = sortedData.indexOf(\n      sortedData.find((item) => item.id === targetId)\n   );\n   const prevItem = sortedData[indexOfTargetId - 1];\n   const nextItem = sortedData[indexOfTargetId + 1];\n   const currentItem = sortedData[indexOfTargetId];\n   const prevDiff = Math.abs(currentItem.value - prevItem.value);\n   const nextDiff = Math.abs(nextItem.value - currentItem.value);\n   const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n   return nearestItem.id;\n};\nconst findNearestIds = (\n   sortedData,\n   targetId,\n   cellsCount,\n   ids = [],\n   step = 0\n) => {\n   if (step < cellsCount) {\n      if (checkTargetValueIsLowest(sortedData, targetId)) {\n         ids.push(getNearestIdsOfLowestValue(sortedData, cellsCount - step));\n         return ids.flat();\n      } else if (checkTargetValueIsBiggest(sortedData, targetId)) {\n         ids.push(getNearestIdsOfBiggestValue(sortedData, cellsCount - step));\n         return ids.flat();\n      } else {\n         const id = getNearestId(sortedData, targetId);\n         ids.push(id);\n         sortedData = sortedData.filter((item) => item.id !== id);\n         step++;\n         return findNearestIds(sortedData, targetId, cellsCount, ids, step);\n      }\n   }\n   return ids;\n};\nconst getIds = (sortedData, cellsCount, targetId) => {\n   const targetValue = sortedData.find((item) => item.id === targetId).value;\n   const sameValueIds = sortedData\n      .filter((item) => item.value === targetValue && item.id !== targetId)\n      .map((item) => item.id);\n   if (sameValueIds.length > 0) {\n      sortedData = sortedData.filter((item) => !sameValueIds.includes(item.id));\n   }\n   const nearestIds = findNearestIds(sortedData, targetId, cellsCount);\n   return { sameValueIds, ids: nearestIds };\n};\n\nexport default getIds;\n"]},"metadata":{},"sourceType":"module"}