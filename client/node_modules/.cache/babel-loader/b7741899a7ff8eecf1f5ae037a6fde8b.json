{"ast":null,"code":"import { CELL_INPUT, COLUMN_INPUT, ROW_INPUT } from \"../../SETTINGS_INPUT_IDS\";\nimport { INCREMENT_CELL, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS, SET_SETTINGS, INCREMENT_INPUT, DECREMENT_INPUT, RESET_SETTINGS } from \"../types\";\nconst initialState = {\n  settings: {\n    rowsCount: 0,\n    columnsCount: 0,\n    cellsCount: 0\n  },\n  data: [],\n  sortedData: [],\n  nearestIds: {\n    sameValueIds: [],\n    ids: []\n  }\n};\n\nconst incrementCell = (id, settings) => {\n  switch (id) {\n    case ROW_INPUT:\n      return settings.rowsCount++;\n\n    case COLUMN_INPUT:\n      return settings.columnsCount++;\n\n    case CELL_INPUT:\n      return settings.cellsCount++;\n\n    default:\n      return settings;\n  }\n};\n\nconst decrementCell = (id, settings) => {\n  switch (id) {\n    case ROW_INPUT:\n      return settings.rowsCount--;\n\n    case COLUMN_INPUT:\n      return settings.columnsCount--;\n\n    case CELL_INPUT:\n      return settings.cellsCount--;\n\n    default:\n      return settings;\n  }\n};\n\nconst sortData = data => {\n  if (data.length > 0) {\n    return data.flat().sort((a, b) => a.value - b.value);\n  }\n}; //Building matrix functions\n\n\nconst addCells = (columnsCount, row = [], step = 0) => {\n  while (step < columnsCount) {\n    row.push({\n      id: `${Date.now()}${Math.round(1 + Math.random() * 9999)}${step}`,\n      value: Math.round(100 + Math.random() * 899)\n    });\n    step++;\n  }\n\n  return row;\n};\n\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n  while (step < rowsCount) {\n    const rowCells = addCells(columnsCount);\n    data.push(rowCells);\n    step++;\n  }\n\n  return data;\n};\n\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n  return addRows(data, rowsCount, columnsCount);\n};\n\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n  const rebuildColumns = () => {\n    let columnsCountDiff = 0;\n\n    if (prevSettings.columnsCount < newSettings.columnsCount) {\n      columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n      data.forEach((row, index) => addCells(columnsCountDiff, row));\n    } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n      columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n      data.forEach(row => row.splice(-columnsCountDiff));\n    }\n\n    return data;\n  };\n\n  const rebuildRows = () => {\n    let rowsCountDiff = 0;\n\n    if (prevSettings.rowsCount < newSettings.rowsCount) {\n      rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n      addRows(data, rowsCountDiff, newSettings.columnsCount);\n    } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n      rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n      data.splice(-rowsCountDiff);\n    }\n\n    return data;\n  };\n\n  rebuildColumns(data, prevSettings, newSettings);\n  rebuildRows(data, prevSettings, newSettings);\n  return data;\n}; //\n//find nearest values functions\n\n\nconst checkTargetValueIsLowest = (data, targetId) => {\n  if (data.indexOf(data.find(item => item.id === targetId)) === 0) {\n    return true;\n  }\n};\n\nconst checkTargetValueIsBiggest = (data, targetId) => {\n  if (data.indexOf(data.find(item => item.id === targetId)) === data.length - 1) {\n    return true;\n  }\n};\n\nconst getNearestIdsOfLowestValue = (data, cellsCount) => {\n  return data.slice(1, cellsCount + 1).map(item => item.id);\n};\n\nconst getNearestIdsOfBiggestValue = (data, cellsCount) => {\n  return data.slice(-cellsCount - 1, -1).map(item => item.id);\n};\n\nconst getNearestId = (data, targetId) => {\n  const indexOfTargetId = data.indexOf(data.find(item => item.id === targetId));\n  const prevItem = data[indexOfTargetId - 1];\n  const nextItem = data[indexOfTargetId + 1];\n  const currentItem = data[indexOfTargetId];\n  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n  return nearestItem.id;\n};\n\nconst findNearestIds = (data, targetId, cellsCount, ids = [], step = 0) => {\n  while (step < cellsCount) {\n    if (checkTargetValueIsLowest(data, targetId)) {\n      ids.push(getNearestIdsOfLowestValue(data, cellsCount - step));\n      return ids.flat();\n    } else if (checkTargetValueIsBiggest(data, targetId)) {\n      ids.push(getNearestIdsOfBiggestValue(data, cellsCount - step));\n      return ids.flat();\n    } else {\n      const id = getNearestId(data, targetId);\n      ids.push(id);\n      data = data.filter(item => item.id !== id);\n      step++;\n      return findNearestIds(data, targetId, cellsCount, ids, step);\n    }\n  }\n\n  return ids;\n};\n\nconst getIds = (data, cellsCount, targetId) => {\n  const targetValue = data.find(item => item.id === targetId).value;\n  const sameValueIds = data.filter(item => item.value === targetValue && item.id !== targetId).map(item => item.id);\n\n  if (sameValueIds.length > 0) {\n    data = data.filter(item => !sameValueIds.includes(item.id));\n  }\n\n  const nearestIds = findNearestIds(data, targetId, cellsCount);\n  return {\n    sameValueIds,\n    ids: nearestIds\n  };\n};\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings = { ...state.settings\n  },\n      data = [...state.data],\n      sortedData = [...state.sortedData],\n      nearestIds;\n\n  switch (action.type) {\n    case INCREMENT_INPUT:\n      incrementCell(action.id, settings);\n      return { ...state,\n        settings\n      };\n\n    case DECREMENT_INPUT:\n      decrementCell(action.id, settings);\n      return { ...state,\n        settings\n      };\n\n    case SET_SETTINGS:\n      const newSettings = { ...action.settings\n      };\n\n      if (data.length === 0) {\n        data = createMatrix(newSettings.rowsCount, newSettings.columnsCount);\n      } else if (settings.rowsCount !== newSettings.rowsCount || settings.columnsCount !== newSettings.columnsCount) {\n        rebuildMatrix(data, settings, newSettings);\n      }\n\n      sortedData = sortData(data);\n      settings = newSettings;\n      return { ...state,\n        data,\n        sortedData,\n        settings\n      };\n\n    case RESET_SETTINGS:\n      return { ...state,\n        settings: {\n          rowsCount: 0,\n          columnsCount: 0,\n          cellsCount: 0\n        },\n        sortedData: []\n      };\n\n    case ADD_ROW:\n      addRows(data, 1, settings.columnsCount);\n      settings.rowsCount = data.length;\n      sortedData = sortData(data);\n      return { ...state,\n        settings,\n        sortedData,\n        data\n      };\n\n    case REMOVE_ROW:\n      data.splice(action.rowIndex, 1);\n      settings.rowsCount = data.length;\n      sortedData = sortData(data);\n      return { ...state,\n        data,\n        sortedData,\n        settings\n      };\n\n    case INCREMENT_CELL:\n      data.find(row => row.find(item => item.id === action.id ? item.value++ : null));\n      sortedData = sortData(data);\n      nearestIds = { ...state.nearestIds\n      };\n      nearestIds = getIds(sortedData, settings.cellsCount, action.id);\n      return { ...state,\n        data,\n        sortedData,\n        nearestIds\n      };\n\n    case SET_NEAREST_IDS:\n      nearestIds = { ...state.nearestIds\n      };\n      nearestIds = getIds(sortedData, settings.cellsCount, action.id);\n      return { ...state,\n        nearestIds\n      };\n\n    case RESET_NEAREST_IDS:\n      nearestIds = { ...state.nearestIds\n      };\n      nearestIds = {\n        sameValueIds: [],\n        ids: []\n      };\n      return { ...state,\n        nearestIds: {\n          sameValueIds: [],\n          ids: []\n        }\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["CELL_INPUT","COLUMN_INPUT","ROW_INPUT","INCREMENT_CELL","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","SET_SETTINGS","INCREMENT_INPUT","DECREMENT_INPUT","RESET_SETTINGS","initialState","settings","rowsCount","columnsCount","cellsCount","data","sortedData","nearestIds","sameValueIds","ids","incrementCell","id","decrementCell","sortData","length","flat","sort","a","b","value","addCells","row","step","push","Date","now","Math","round","random","addRows","rowCells","createMatrix","rebuildMatrix","prevSettings","newSettings","rebuildColumns","columnsCountDiff","forEach","index","splice","rebuildRows","rowsCountDiff","checkTargetValueIsLowest","targetId","indexOf","find","item","checkTargetValueIsBiggest","getNearestIdsOfLowestValue","slice","map","getNearestIdsOfBiggestValue","getNearestId","indexOfTargetId","prevItem","nextItem","currentItem","prevDiff","abs","nextDiff","nearestItem","findNearestIds","filter","getIds","targetValue","includes","matrixReducer","state","action","type","rowIndex"],"mappings":"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","sourcesContent":["import { CELL_INPUT, COLUMN_INPUT, ROW_INPUT } from \"../../SETTINGS_INPUT_IDS\";\nimport {\n   INCREMENT_CELL,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n   SET_SETTINGS,\n   INCREMENT_INPUT,\n   DECREMENT_INPUT,\n   RESET_SETTINGS,\n} from \"../types\";\n\nconst initialState = {\n   settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n   data: [],\n   sortedData: [],\n   nearestIds: { sameValueIds: [], ids: [] },\n};\n\nconst incrementCell = (id, settings) => {\n   switch (id) {\n      case ROW_INPUT:\n         return settings.rowsCount++;\n      case COLUMN_INPUT:\n         return settings.columnsCount++;\n      case CELL_INPUT:\n         return settings.cellsCount++;\n      default:\n         return settings;\n   }\n};\nconst decrementCell = (id, settings) => {\n   switch (id) {\n      case ROW_INPUT:\n         return settings.rowsCount--;\n      case COLUMN_INPUT:\n         return settings.columnsCount--;\n      case CELL_INPUT:\n         return settings.cellsCount--;\n      default:\n         return settings;\n   }\n};\n\nconst sortData = (data) => {\n   if (data.length > 0) {\n      return data.flat().sort((a, b) => a.value - b.value);\n   }\n};\n//Building matrix functions\nconst addCells = (columnsCount, row = [], step = 0) => {\n   while (step < columnsCount) {\n      row.push({\n         id: `${Date.now()}${Math.round(1 + Math.random() * 9999)}${step}`,\n         value: Math.round(100 + Math.random() * 899),\n      });\n      step++;\n   }\n   return row;\n};\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n   while (step < rowsCount) {\n      const rowCells = addCells(columnsCount);\n      data.push(rowCells);\n      step++;\n   }\n   return data;\n};\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n   return addRows(data, rowsCount, columnsCount);\n};\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n   const rebuildColumns = () => {\n      let columnsCountDiff = 0;\n      if (prevSettings.columnsCount < newSettings.columnsCount) {\n         columnsCountDiff =\n            newSettings.columnsCount - prevSettings.columnsCount;\n         data.forEach((row, index) => addCells(columnsCountDiff, row));\n      } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n         columnsCountDiff =\n            prevSettings.columnsCount - newSettings.columnsCount;\n         data.forEach((row) => row.splice(-columnsCountDiff));\n      }\n      return data;\n   };\n   const rebuildRows = () => {\n      let rowsCountDiff = 0;\n      if (prevSettings.rowsCount < newSettings.rowsCount) {\n         rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n         addRows(data, rowsCountDiff, newSettings.columnsCount);\n      } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n         rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n         data.splice(-rowsCountDiff);\n      }\n      return data;\n   };\n   rebuildColumns(data, prevSettings, newSettings);\n   rebuildRows(data, prevSettings, newSettings);\n   return data;\n};\n//\n//find nearest values functions\nconst checkTargetValueIsLowest = (data, targetId) => {\n   if (data.indexOf(data.find((item) => item.id === targetId)) === 0) {\n      return true;\n   }\n};\nconst checkTargetValueIsBiggest = (data, targetId) => {\n   if (\n      data.indexOf(data.find((item) => item.id === targetId)) ===\n      data.length - 1\n   ) {\n      return true;\n   }\n};\nconst getNearestIdsOfLowestValue = (data, cellsCount) => {\n   return data.slice(1, cellsCount + 1).map((item) => item.id);\n};\nconst getNearestIdsOfBiggestValue = (data, cellsCount) => {\n   return data.slice(-cellsCount - 1, -1).map((item) => item.id);\n};\nconst getNearestId = (data, targetId) => {\n   const indexOfTargetId = data.indexOf(\n      data.find((item) => item.id === targetId)\n   );\n   const prevItem = data[indexOfTargetId - 1];\n   const nextItem = data[indexOfTargetId + 1];\n   const currentItem = data[indexOfTargetId];\n   const prevDiff = Math.abs(currentItem.value - prevItem.value);\n   const nextDiff = Math.abs(nextItem.value - currentItem.value);\n   const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n   return nearestItem.id;\n};\nconst findNearestIds = (data, targetId, cellsCount, ids = [], step = 0) => {\n   while (step < cellsCount) {\n      if (checkTargetValueIsLowest(data, targetId)) {\n         ids.push(getNearestIdsOfLowestValue(data, cellsCount - step));\n         return ids.flat();\n      } else if (checkTargetValueIsBiggest(data, targetId)) {\n         ids.push(getNearestIdsOfBiggestValue(data, cellsCount - step));\n         return ids.flat();\n      } else {\n         const id = getNearestId(data, targetId);\n         ids.push(id);\n         data = data.filter((item) => item.id !== id);\n         step++;\n         return findNearestIds(data, targetId, cellsCount, ids, step);\n      }\n   }\n   return ids;\n};\nconst getIds = (data, cellsCount, targetId) => {\n   const targetValue = data.find((item) => item.id === targetId).value;\n   const sameValueIds = data\n      .filter((item) => item.value === targetValue && item.id !== targetId)\n      .map((item) => item.id);\n   if (sameValueIds.length > 0) {\n      data = data.filter((item) => !sameValueIds.includes(item.id));\n   }\n   const nearestIds = findNearestIds(data, targetId, cellsCount);\n   return { sameValueIds, ids: nearestIds };\n};\n\nconst matrixReducer = (state = initialState, action) => {\n   let settings = { ...state.settings },\n      data = [...state.data],\n      sortedData = [...state.sortedData],\n      nearestIds;\n   switch (action.type) {\n      case INCREMENT_INPUT:\n         incrementCell(action.id, settings);\n         return { ...state, settings };\n      case DECREMENT_INPUT:\n         decrementCell(action.id, settings);\n         return { ...state, settings };\n      case SET_SETTINGS:\n         const newSettings = { ...action.settings };\n         if (data.length === 0) {\n            data = createMatrix(\n               newSettings.rowsCount,\n               newSettings.columnsCount\n            );\n         } else if (\n            settings.rowsCount !== newSettings.rowsCount ||\n            settings.columnsCount !== newSettings.columnsCount\n         ) {\n            rebuildMatrix(data, settings, newSettings);\n         }\n         sortedData = sortData(data);\n         settings = newSettings;\n         return { ...state, data, sortedData, settings };\n      case RESET_SETTINGS:\n         return {\n            ...state,\n            settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n            sortedData: [],\n         };\n      case ADD_ROW:\n         addRows(data, 1, settings.columnsCount);\n         settings.rowsCount = data.length;\n         sortedData = sortData(data);\n         return { ...state, settings, sortedData, data };\n      case REMOVE_ROW:\n         data.splice(action.rowIndex, 1);\n         settings.rowsCount = data.length;\n         sortedData = sortData(data);\n         return { ...state, data, sortedData, settings };\n      case INCREMENT_CELL:\n         data.find((row) =>\n            row.find((item) => (item.id === action.id ? item.value++ : null))\n         );\n         sortedData = sortData(data);\n         nearestIds = { ...state.nearestIds };\n         nearestIds = getIds(sortedData, settings.cellsCount, action.id);\n         return { ...state, data, sortedData, nearestIds };\n      case SET_NEAREST_IDS:\n         nearestIds = { ...state.nearestIds };\n         nearestIds = getIds(sortedData, settings.cellsCount, action.id);\n         return { ...state, nearestIds };\n      case RESET_NEAREST_IDS:\n         nearestIds = { ...state.nearestIds };\n         nearestIds = { sameValueIds: [], ids: [] };\n         return { ...state, nearestIds: { sameValueIds: [], ids: [] } };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}