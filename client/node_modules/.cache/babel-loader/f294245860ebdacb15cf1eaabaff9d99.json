{"ast":null,"code":"import { INCREMENT_CELL, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS, SET_SETTINGS } from \"../types\";\nconst initialState = {\n  settings: {\n    rowsCount: 0,\n    columnsCount: 0,\n    cellsCount: 0\n  },\n  nearestIds: [],\n  data: []\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n  while (step < columnsCount) {\n    row.push({\n      id: String(rowNumber + 1).concat(row.length + 1),\n      value: Math.round(100 + Math.random() * 899)\n    });\n    step++;\n  }\n\n  return row;\n};\n\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n  while (step < rowsCount) {\n    const rowCells = addCells(data.length, columnsCount);\n    data.push(rowCells);\n    step++;\n  }\n\n  console.log(data);\n  return data;\n};\n\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n  return addRows(data, rowsCount, columnsCount);\n};\n\nconst rebuildColumns = (data, prevSettings, newSettings) => {\n  let columnsCountDiff = 0;\n\n  if (prevSettings.columnsCount < newSettings.columnsCount) {\n    columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n    data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n  } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n    columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n    data.forEach(row => row.splice(-columnsCountDiff));\n  }\n\n  return data;\n};\n\nconst rebuildRows = (data, prevSettings, newSettings) => {\n  let rowsCountDiff = 0;\n\n  if (prevSettings.rowsCount < newSettings.rowsCount) {\n    rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n    addRows(data, rowsCountDiff, newSettings.columnsCount);\n  } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n    rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n    data.splice(-rowsCountDiff);\n  }\n\n  return data;\n};\n\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n  rebuildColumns(data, prevSettings, newSettings);\n  rebuildRows(data, prevSettings, newSettings);\n  return data;\n};\n\nconst findNearestIds = (matrixData, cellsCount, id) => {\n  if (+cellsCount === 0) {\n    return [];\n  } else {\n    let nearestIds = [];\n    let sortedMatrix = matrixData.reduce((currentRow, nextRow) => currentRow.concat(nextRow), []).sort((a, b) => a.value - b.value);\n    const iterationCount = cellsCount < sortedMatrix.length ? cellsCount : sortedMatrix.length - 1;\n    let indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n    const exclusionIds = indexCurrentId => sortedMatrix.filter((item, index) => index !== indexCurrentId).forEach(item => nearestIds.push(item.id)); //get ids when the hovered item is the lowest\n\n\n    if (indexCurrentId === 0) {\n      sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(1, iterationCount).forEach(item => nearestIds.push(item.id));\n    } //get ids when the hovered item is the biggest\n    else if (indexCurrentId === sortedMatrix.length - 1) {\n        sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(-iterationCount - 1, iterationCount).forEach(item => nearestIds.push(item.id));\n      } //other options\n      else {\n          if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n          } else {\n            for (let i = 0; i < iterationCount; i++) {\n              indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n              if (indexCurrentId === 0) {\n                sortedMatrix.splice(1, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else if (indexCurrentId === sortedMatrix.length - 1) {\n                const from = -indexCurrentId - iterationCount - i - 1;\n                sortedMatrix.splice(from, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else {\n                const prevItem = sortedMatrix[indexCurrentId - 1];\n                const nextItem = sortedMatrix[indexCurrentId + 1];\n                const currentItem = sortedMatrix[indexCurrentId];\n                const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                nearestIds.push(nearestItem.id);\n                sortedMatrix.splice(sortedMatrix.indexOf(sortedMatrix.find(item => item === nearestItem)), 1);\n              }\n            }\n          }\n        }\n\n    return nearestIds;\n  }\n};\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings = { ...state.settings\n  },\n      data = [...state.data],\n      nearestIds;\n\n  switch (action.type) {\n    case SET_SETTINGS:\n      const newSettings = { ...action.settings\n      };\n\n      if (data.length === 0) {\n        data = createMatrix(newSettings.rowsCount, newSettings.columnsCount);\n      } else if (settings.rowsCount !== newSettings.rowsCount || settings.columnsCount !== newSettings.columnsCount) {\n        rebuildMatrix(data, settings, newSettings);\n      }\n\n      settings = newSettings;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case ADD_ROW:\n      addRows(data, 1, settings.columnsCount);\n      settings.rowsCount = data.length;\n      return { ...state,\n        settings,\n        data\n      };\n\n    case REMOVE_ROW:\n      data.splice(action.rowIndex, 1);\n      settings.rowsCount = data.length;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case INCREMENT_CELL:\n      data.find(row => row.find(item => item.id === action.id ? item.value++ : null));\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        data,\n        nearestIds\n      };\n\n    case SET_NEAREST_IDS:\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        nearestIds\n      };\n\n    case RESET_NEAREST_IDS:\n      data = [...state.data];\n      nearestIds = [];\n      return { ...state,\n        nearestIds\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["INCREMENT_CELL","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","SET_SETTINGS","initialState","settings","rowsCount","columnsCount","cellsCount","nearestIds","data","addCells","rowNumber","row","step","push","id","String","concat","length","value","Math","round","random","addRows","rowCells","console","log","createMatrix","rebuildColumns","prevSettings","newSettings","columnsCountDiff","forEach","index","splice","rebuildRows","rowsCountDiff","rebuildMatrix","findNearestIds","matrixData","sortedMatrix","reduce","currentRow","nextRow","sort","a","b","iterationCount","indexCurrentId","indexOf","find","item","exclusionIds","filter","i","from","prevItem","nextItem","currentItem","prevDiff","abs","nextDiff","nearestItem","matrixReducer","state","action","type","rowIndex"],"mappings":"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","sourcesContent":["import {\n   INCREMENT_CELL,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n   SET_SETTINGS,\n} from \"../types\";\n\nconst initialState = {\n   settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n   nearestIds: [],\n   data: [],\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n   while (step < columnsCount) {\n      row.push({\n         id: String(rowNumber + 1).concat(row.length + 1),\n         value: Math.round(100 + Math.random() * 899),\n      });\n      step++;\n   }\n   return row;\n};\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n   while (step < rowsCount) {\n      const rowCells = addCells(data.length, columnsCount);\n      data.push(rowCells);\n      step++;\n   }\n   console.log(data)\n   return data;\n};\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n   return addRows(data, rowsCount, columnsCount);\n};\nconst rebuildColumns = (data, prevSettings, newSettings) => {\n   let columnsCountDiff = 0;\n   if (prevSettings.columnsCount < newSettings.columnsCount) {\n      columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n      data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n   } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n      columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n      data.forEach((row) => row.splice(-columnsCountDiff));\n   }\n   return data;\n};\nconst rebuildRows = (data, prevSettings, newSettings) => {\n   let rowsCountDiff = 0;\n   if (prevSettings.rowsCount < newSettings.rowsCount) {\n      rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n      addRows(data, rowsCountDiff, newSettings.columnsCount);\n   } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n      rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n      data.splice(-rowsCountDiff);\n   }\n   return data;\n};\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n   rebuildColumns(data, prevSettings, newSettings);\n   rebuildRows(data, prevSettings, newSettings);\n   return data;\n};\nconst findNearestIds = (matrixData, cellsCount, id) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow), [])\n         .sort((a, b) => a.value - b.value);\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentId = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.id === id)\n      );\n      const exclusionIds = (indexCurrentId) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentId)\n            .forEach((item) => nearestIds.push(item.id));\n      //get ids when the hovered item is the lowest\n      if (indexCurrentId === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //get ids when the hovered item is the biggest\n      else if (indexCurrentId === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //other options\n      else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               indexCurrentId = sortedMatrix.indexOf(\n                  sortedMatrix.find((item) => item.id === id)\n               );\n               if (indexCurrentId === 0) {\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentId === sortedMatrix.length - 1) {\n                  const from = -indexCurrentId - iterationCount - i - 1;\n                  sortedMatrix\n                     .splice(from, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  const prevItem = sortedMatrix[indexCurrentId - 1];\n                  const nextItem = sortedMatrix[indexCurrentId + 1];\n                  const currentItem = sortedMatrix[indexCurrentId];\n                  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                  nearestIds.push(nearestItem.id);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item === nearestItem)\n                     ),\n                     1\n                  );\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n};\n\nconst matrixReducer = (state = initialState, action) => {\n   let settings = { ...state.settings },\n      data = [...state.data],\n      nearestIds;\n   switch (action.type) {\n      case SET_SETTINGS:\n         const newSettings = { ...action.settings };\n         if (data.length === 0) {\n            data = createMatrix(\n               newSettings.rowsCount,\n               newSettings.columnsCount\n            );\n         } else if (\n            settings.rowsCount !== newSettings.rowsCount ||\n            settings.columnsCount !== newSettings.columnsCount\n         ) {\n            rebuildMatrix(data, settings, newSettings);\n         }\n         settings = newSettings;\n         return { ...state, data, settings };\n      case ADD_ROW:\n         addRows(data, 1, settings.columnsCount);\n         settings.rowsCount = data.length;\n         return { ...state, settings, data };\n      case REMOVE_ROW:\n         data.splice(action.rowIndex, 1);\n         settings.rowsCount = data.length;\n         return { ...state, data, settings };\n      case INCREMENT_CELL:\n         data.find((row) =>\n            row.find((item) => (item.id === action.id ? item.value++ : null))\n         );\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, data, nearestIds };\n      case SET_NEAREST_IDS:\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, nearestIds };\n      case RESET_NEAREST_IDS:\n         data = [...state.data];\n         nearestIds = [];\n         return { ...state, nearestIds };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}