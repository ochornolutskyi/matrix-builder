{"ast":null,"code":"import { INCREMENT_CELL, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS, SET_SETTINGS } from \"../types\";\nconst initialState = {\n  settings: {\n    rowsCount: 0,\n    columnsCount: 0,\n    cellsCount: 0\n  },\n  nearestIds: [],\n  data: []\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n  while (step < columnsCount) {\n    row.push({\n      id: String(rowNumber + 1).concat(row.length + 1),\n      value: Math.round(100 + Math.random() * 899)\n    });\n    step++;\n  }\n\n  return row;\n};\n\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n  while (step < rowsCount) {\n    const rowCells = addCells(step, columnsCount);\n    data.push(rowCells);\n    step++;\n  }\n\n  return data;\n};\n\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n  return addRows(data, rowsCount, columnsCount);\n};\n\nconst rebuildColumns = (data, prevSettings, newSettings) => {\n  let columnsCountDiff = 0;\n\n  if (prevSettings.columnsCount < newSettings.columnsCount) {\n    columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n    data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n  } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n    columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n    data.forEach(row => row.splice(-columnsCountDiff));\n  }\n\n  return data;\n};\n\nconst rebuildRows = (data, prevSettings, newSettings) => {\n  let rowsCountDiff = 0;\n\n  if (prevSettings.rowsCount < newSettings.rowsCount) {\n    rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n    addRows(data, rowsCountDiff, newSettings.columnsCount);\n  } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n    rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n    data.splice(-rowsCountDiff);\n  }\n\n  return data;\n};\n\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n  rebuildColumns(data, prevSettings, newSettings);\n  rebuildRows(data, prevSettings, newSettings);\n  return data;\n};\n\nconst findNearestIds = (matrixData, cellsCount, id) => {\n  if (+cellsCount === 0) {\n    return [];\n  } else {\n    let nearestIds = [];\n    let sortedMatrix = matrixData.reduce((currentRow, nextRow) => currentRow.concat(nextRow), []).sort((a, b) => a.value - b.value);\n    const iterationCount = cellsCount < sortedMatrix.length ? cellsCount : sortedMatrix.length - 1;\n    let indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n    const exclusionIds = indexCurrentId => sortedMatrix.filter((item, index) => index !== indexCurrentId).forEach(item => nearestIds.push(item.id)); //get ids when the hovered item is the lowest\n\n\n    if (indexCurrentId === 0) {\n      sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(1, iterationCount).forEach(item => nearestIds.push(item.id));\n    } //get ids when the hovered item is the biggest\n    else if (indexCurrentId === sortedMatrix.length - 1) {\n        sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentId) : sortedMatrix.splice(-iterationCount - 1, iterationCount).forEach(item => nearestIds.push(item.id));\n      } //other options\n      else {\n          if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n          } else {\n            for (let i = 0; i < iterationCount; i++) {\n              indexCurrentId = sortedMatrix.indexOf(sortedMatrix.find(item => item.id === id));\n\n              if (indexCurrentId === 0) {\n                sortedMatrix.splice(1, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else if (indexCurrentId === sortedMatrix.length - 1) {\n                const from = -indexCurrentId - iterationCount - i - 1;\n                sortedMatrix.splice(from, iterationCount - i).forEach(item => nearestIds.push(item.id));\n                break;\n              } else {\n                const prevItem = sortedMatrix[indexCurrentId - 1];\n                const nextItem = sortedMatrix[indexCurrentId + 1];\n                const currentItem = sortedMatrix[indexCurrentId];\n                const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                nearestIds.push(nearestItem.id);\n                sortedMatrix.splice(sortedMatrix.indexOf(sortedMatrix.find(item => item === nearestItem)), 1);\n              }\n            }\n          }\n        }\n\n    return nearestIds;\n  }\n};\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings = { ...state.settings\n  },\n      data = [...state.data],\n      nearestIds;\n\n  switch (action.type) {\n    case SET_SETTINGS:\n      const newSettings = { ...action.settings\n      };\n\n      if (data.length === 0) {\n        data = createMatrix(newSettings.rowsCount, newSettings.columnsCount);\n      } else if (settings.rowsCount !== newSettings.rowsCount || settings.columnsCount !== newSettings.columnsCount) {\n        rebuildMatrix(data, settings, newSettings);\n      }\n\n      settings = newSettings;\n      console.log(data);\n      return { ...state,\n        data,\n        settings\n      };\n\n    case ADD_ROW:\n      addRows(data, 1, settings.columnsCount);\n      settings.rowsCount = data.length;\n      return { ...state,\n        settings,\n        data\n      };\n\n    case REMOVE_ROW:\n      data.splice(action.rowIndex, 1);\n      settings.rowsCount = data.length;\n      return { ...state,\n        data,\n        settings\n      };\n\n    case INCREMENT_CELL:\n      data.find(row => row.find(item => item.id === action.id ? item.value++ : null));\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        data,\n        nearestIds\n      };\n\n    case SET_NEAREST_IDS:\n      nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n      return { ...state,\n        nearestIds\n      };\n\n    case RESET_NEAREST_IDS:\n      data = [...state.data];\n      nearestIds = [];\n      return { ...state,\n        nearestIds\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["INCREMENT_CELL","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","SET_SETTINGS","initialState","settings","rowsCount","columnsCount","cellsCount","nearestIds","data","addCells","rowNumber","row","step","push","id","String","concat","length","value","Math","round","random","addRows","rowCells","createMatrix","rebuildColumns","prevSettings","newSettings","columnsCountDiff","forEach","index","splice","rebuildRows","rowsCountDiff","rebuildMatrix","findNearestIds","matrixData","sortedMatrix","reduce","currentRow","nextRow","sort","a","b","iterationCount","indexCurrentId","indexOf","find","item","exclusionIds","filter","i","from","prevItem","nextItem","currentItem","prevDiff","abs","nextDiff","nearestItem","matrixReducer","state","action","type","console","log","rowIndex"],"mappings":"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","sourcesContent":["import {\n   INCREMENT_CELL,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n   SET_SETTINGS,\n} from \"../types\";\n\nconst initialState = {\n   settings: { rowsCount: 0, columnsCount: 0, cellsCount: 0 },\n   nearestIds: [],\n   data: [],\n};\n\nconst addCells = (rowNumber, columnsCount, row = [], step = 0) => {\n   while (step < columnsCount) {\n      row.push({\n         id: String(rowNumber + 1).concat(row.length + 1),\n         value: Math.round(100 + Math.random() * 899),\n      });\n      step++;\n   }\n   return row;\n};\nconst addRows = (data, rowsCount, columnsCount, step = 0) => {\n   while (step < rowsCount) {\n      const rowCells = addCells(step, columnsCount);\n      data.push(rowCells);\n      step++;\n   }\n   return data;\n};\nconst createMatrix = (rowsCount, columnsCount, data = []) => {\n   return addRows(data, rowsCount, columnsCount);\n};\nconst rebuildColumns = (data, prevSettings, newSettings) => {\n   let columnsCountDiff = 0;\n   if (prevSettings.columnsCount < newSettings.columnsCount) {\n      columnsCountDiff = newSettings.columnsCount - prevSettings.columnsCount;\n      data.forEach((row, index) => addCells(index, columnsCountDiff, row));\n   } else if (prevSettings.columnsCount > newSettings.columnsCount) {\n      columnsCountDiff = prevSettings.columnsCount - newSettings.columnsCount;\n      data.forEach((row) => row.splice(-columnsCountDiff));\n   }\n   return data;\n};\nconst rebuildRows = (data, prevSettings, newSettings) => {\n   let rowsCountDiff = 0;\n   if (prevSettings.rowsCount < newSettings.rowsCount) {\n      rowsCountDiff = newSettings.rowsCount - prevSettings.rowsCount;\n      addRows(data, rowsCountDiff, newSettings.columnsCount);\n   } else if (prevSettings.rowsCount > newSettings.rowsCount) {\n      rowsCountDiff = prevSettings.rowsCount - newSettings.rowsCount;\n      data.splice(-rowsCountDiff);\n   }\n   return data;\n};\nconst rebuildMatrix = (data, prevSettings, newSettings) => {\n   rebuildColumns(data, prevSettings, newSettings);\n   rebuildRows(data, prevSettings, newSettings);\n   return data;\n};\nconst findNearestIds = (matrixData, cellsCount, id) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let nearestIds = [];\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow), [])\n         .sort((a, b) => a.value - b.value);\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentId = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.id === id)\n      );\n      const exclusionIds = (indexCurrentId) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentId)\n            .forEach((item) => nearestIds.push(item.id));\n      //get ids when the hovered item is the lowest\n      if (indexCurrentId === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //get ids when the hovered item is the biggest\n      else if (indexCurrentId === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentId)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      }\n      //other options\n      else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentId);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               indexCurrentId = sortedMatrix.indexOf(\n                  sortedMatrix.find((item) => item.id === id)\n               );\n               if (indexCurrentId === 0) {\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentId === sortedMatrix.length - 1) {\n                  const from = -indexCurrentId - iterationCount - i - 1;\n                  sortedMatrix\n                     .splice(from, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  const prevItem = sortedMatrix[indexCurrentId - 1];\n                  const nextItem = sortedMatrix[indexCurrentId + 1];\n                  const currentItem = sortedMatrix[indexCurrentId];\n                  const prevDiff = Math.abs(currentItem.value - prevItem.value);\n                  const nextDiff = Math.abs(nextItem.value - currentItem.value);\n                  const nearestItem = prevDiff < nextDiff ? prevItem : nextItem;\n                  nearestIds.push(nearestItem.id);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item === nearestItem)\n                     ),\n                     1\n                  );\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n};\n\nconst matrixReducer = (state = initialState, action) => {\n   let settings = { ...state.settings },\n      data = [...state.data],\n      nearestIds;\n   switch (action.type) {\n      case SET_SETTINGS:\n         const newSettings = { ...action.settings };\n         if (data.length === 0) {\n            data = createMatrix(\n               newSettings.rowsCount,\n               newSettings.columnsCount\n            );\n         } else if (\n            settings.rowsCount !== newSettings.rowsCount ||\n            settings.columnsCount !== newSettings.columnsCount\n         ) {\n            rebuildMatrix(data, settings, newSettings);\n         }\n         settings = newSettings;\n         console.log(data)\n         return { ...state, data, settings };\n      case ADD_ROW:\n         addRows(data, 1, settings.columnsCount);\n         settings.rowsCount = data.length;\n         return { ...state, settings, data };\n      case REMOVE_ROW:\n         data.splice(action.rowIndex, 1);\n         settings.rowsCount = data.length;\n         return { ...state, data, settings };\n      case INCREMENT_CELL:\n         data.find((row) =>\n            row.find((item) => (item.id === action.id ? item.value++ : null))\n         );\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, data, nearestIds };\n      case SET_NEAREST_IDS:\n         nearestIds = findNearestIds(data, settings.cellsCount, action.id);\n         return { ...state, nearestIds };\n      case RESET_NEAREST_IDS:\n         data = [...state.data];\n         nearestIds = [];\n         return { ...state, nearestIds };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}