{"ast":null,"code":"import { INCREMENT_CELL, CREATE_MATRIX, REMOVE_ROW, ADD_ROW, SET_NEAREST_IDS, RESET_NEAREST_IDS } from \"../types\";\nconst initialState = {\n  nearestIds: [],\n  data: []\n}; //TODO: row 1 column 3 cells 2\n\nconst findNearestIds = (matrixData, cellsCount, currentValue) => {\n  if (+cellsCount === 0) {\n    return [];\n  } else {\n    let sortedMatrix = matrixData.reduce((currentRow, nextRow) => currentRow.concat(nextRow)).sort((a, b) => a.value - b.value);\n    let nearestIds = [];\n    const iterationCount = cellsCount < sortedMatrix.length ? cellsCount : sortedMatrix.length - 1;\n    let indexCurrentValue = sortedMatrix.indexOf(sortedMatrix.find(item => item.value === currentValue));\n\n    const exclusionIds = indexCurrentValue => sortedMatrix.filter((item, index) => index !== indexCurrentValue).forEach(item => nearestIds.push(item.id));\n\n    if (indexCurrentValue === 0) {\n      sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentValue) : sortedMatrix.splice(1, iterationCount).forEach(item => nearestIds.push(item.id));\n    } else if (indexCurrentValue === sortedMatrix.length - 1) {\n      sortedMatrix.length - 1 === iterationCount ? exclusionIds(indexCurrentValue) : sortedMatrix.splice(-iterationCount - 1, iterationCount).forEach(item => nearestIds.push(item.id));\n    } else {\n      if (sortedMatrix.length - 1 === iterationCount) {\n        exclusionIds(indexCurrentValue);\n      } else {\n        for (let i = 0; i < iterationCount; i++) {\n          const sortedValues = sortedMatrix.map(data => data.value).sort((a, b) => a - b);\n          indexCurrentValue = sortedValues.indexOf(currentValue);\n\n          if (indexCurrentValue === 0) {\n            console.log('indes 0 for');\n            sortedMatrix.splice(1, iterationCount - i).forEach(item => nearestIds.push(item.id));\n            break;\n          } else if (indexCurrentValue === sortedMatrix.length - 1) {\n            sortedMatrix.splice(-iterationCount - i - 1, iterationCount - i).forEach(item => nearestIds.push(item.id));\n            break;\n          } else {\n            console.log('indes  for');\n            const prevValue = sortedValues[indexCurrentValue - 1];\n            const nextValue = sortedValues[indexCurrentValue + 1];\n            const prevDiff = Math.abs(currentValue - prevValue);\n            const nextDiff = Math.abs(nextValue - currentValue);\n            const nearestValue = prevDiff < nextDiff ? prevValue : nextValue;\n            const nearestId = sortedMatrix.find(item => item.value === nearestValue).id;\n            nearestIds.push(nearestId);\n            sortedMatrix.splice(sortedMatrix.indexOf(sortedMatrix.find(item => item.id === nearestId)), 1);\n            console.log(nearestids);\n          }\n        }\n      }\n    }\n\n    return nearestIds;\n  }\n};\n\nconst matrixReducer = (state = initialState, action) => {\n  let settings, data, ids;\n\n  switch (action.type) {\n    case CREATE_MATRIX:\n      data = [...state.data];\n      settings = action.settings;\n\n      for (let i = 0; i < settings.rows; i++) {\n        data.push([]);\n      }\n\n      data.forEach((item, index) => {\n        for (let i = 0; i < settings.columns; i++) {\n          const cellObject = {\n            id: String(index + 1).concat(i + 1),\n            value: Math.round(100 + Math.random() * 899)\n          };\n          item.push(cellObject);\n        }\n      });\n      return { ...state,\n        data\n      };\n\n    case INCREMENT_CELL:\n      data = [...state.data];\n      data.find(row => row.find(item => item.id === action.id)).filter(item => item.id === action.id)[0].value++;\n      return { ...state,\n        data\n      };\n\n    case REMOVE_ROW:\n      data = [...state.data];\n      data.splice(action.index, 1);\n      return { ...state,\n        data\n      };\n\n    case ADD_ROW:\n      data = [...state.data];\n      let newRow = [];\n\n      for (let i = 0; i < action.columnsCount; i++) {\n        const cellObject = {\n          id: String(data.length + 1).concat(i + 1),\n          value: Math.round(100 + Math.random() * 899)\n        };\n        newRow.push(cellObject);\n      }\n\n      data.push(newRow);\n      return { ...state,\n        data\n      };\n\n    case SET_NEAREST_IDS:\n      data = [...state.data];\n      const cellsCount = action.cellsCount;\n      const currentValue = action.currentValue;\n      ids = findNearestIds(data, cellsCount, currentValue);\n      return { ...state,\n        nearestIds: ids\n      };\n\n    case RESET_NEAREST_IDS:\n      ids = [...state.nearestIds];\n      ids = [];\n      return { ...state,\n        nearestIds: ids\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport default matrixReducer;","map":{"version":3,"sources":["/home/superproger/workspace/matrix-builder/client/src/redux/reducers/matrixReducer.js"],"names":["INCREMENT_CELL","CREATE_MATRIX","REMOVE_ROW","ADD_ROW","SET_NEAREST_IDS","RESET_NEAREST_IDS","initialState","nearestIds","data","findNearestIds","matrixData","cellsCount","currentValue","sortedMatrix","reduce","currentRow","nextRow","concat","sort","a","b","value","iterationCount","length","indexCurrentValue","indexOf","find","item","exclusionIds","filter","index","forEach","push","id","splice","i","sortedValues","map","console","log","prevValue","nextValue","prevDiff","Math","abs","nextDiff","nearestValue","nearestId","nearestids","matrixReducer","state","action","settings","ids","type","rows","columns","cellObject","String","round","random","row","newRow","columnsCount"],"mappings":"AAAA,SACGA,cADH,EAEGC,aAFH,EAGGC,UAHH,EAIGC,OAJH,EAKGC,eALH,EAMGC,iBANH,QAOO,UAPP;AASA,MAAMC,YAAY,GAAG;AAAEC,EAAAA,UAAU,EAAE,EAAd;AAAkBC,EAAAA,IAAI,EAAE;AAAxB,CAArB,C,CACA;;AACA,MAAMC,cAAc,GAAG,CAACC,UAAD,EAAaC,UAAb,EAAyBC,YAAzB,KAA0C;AAC9D,MAAI,CAACD,UAAD,KAAgB,CAApB,EAAuB;AACpB,WAAO,EAAP;AACF,GAFD,MAEO;AACJ,QAAIE,YAAY,GAAGH,UAAU,CACzBI,MADe,CACR,CAACC,UAAD,EAAaC,OAAb,KAAyBD,UAAU,CAACE,MAAX,CAAkBD,OAAlB,CADjB,EAEfE,IAFe,CAEV,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,KAAF,GAAUD,CAAC,CAACC,KAFZ,CAAnB;AAGA,QAAId,UAAU,GAAG,EAAjB;AACA,UAAMe,cAAc,GACjBX,UAAU,GAAGE,YAAY,CAACU,MAA1B,GACKZ,UADL,GAEKE,YAAY,CAACU,MAAb,GAAsB,CAH9B;AAIA,QAAIC,iBAAiB,GAAGX,YAAY,CAACY,OAAb,CACrBZ,YAAY,CAACa,IAAb,CAAmBC,IAAD,IAAUA,IAAI,CAACN,KAAL,KAAeT,YAA3C,CADqB,CAAxB;;AAGA,UAAMgB,YAAY,GAAIJ,iBAAD,IAClBX,YAAY,CACRgB,MADJ,CACW,CAACF,IAAD,EAAOG,KAAP,KAAiBA,KAAK,KAAKN,iBADtC,EAEIO,OAFJ,CAEaJ,IAAD,IAAUpB,UAAU,CAACyB,IAAX,CAAgBL,IAAI,CAACM,EAArB,CAFtB,CADH;;AAIA,QAAIT,iBAAiB,KAAK,CAA1B,EAA6B;AAC1BX,MAAAA,YAAY,CAACU,MAAb,GAAsB,CAAtB,KAA4BD,cAA5B,GACKM,YAAY,CAACJ,iBAAD,CADjB,GAEKX,YAAY,CACRqB,MADJ,CACW,CADX,EACcZ,cADd,EAEIS,OAFJ,CAEaJ,IAAD,IAAUpB,UAAU,CAACyB,IAAX,CAAgBL,IAAI,CAACM,EAArB,CAFtB,CAFL;AAKF,KAND,MAMO,IAAIT,iBAAiB,KAAKX,YAAY,CAACU,MAAb,GAAsB,CAAhD,EAAmD;AACvDV,MAAAA,YAAY,CAACU,MAAb,GAAsB,CAAtB,KAA4BD,cAA5B,GACKM,YAAY,CAACJ,iBAAD,CADjB,GAEKX,YAAY,CACRqB,MADJ,CACW,CAACZ,cAAD,GAAkB,CAD7B,EACgCA,cADhC,EAEIS,OAFJ,CAEaJ,IAAD,IAAUpB,UAAU,CAACyB,IAAX,CAAgBL,IAAI,CAACM,EAArB,CAFtB,CAFL;AAKF,KANM,MAMA;AACJ,UAAIpB,YAAY,CAACU,MAAb,GAAsB,CAAtB,KAA4BD,cAAhC,EAAgD;AAC7CM,QAAAA,YAAY,CAACJ,iBAAD,CAAZ;AACF,OAFD,MAEO;AACJ,aAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,cAApB,EAAoCa,CAAC,EAArC,EAAyC;AACtC,gBAAMC,YAAY,GAAGvB,YAAY,CAC7BwB,GADiB,CACZ7B,IAAD,IAAUA,IAAI,CAACa,KADF,EAEjBH,IAFiB,CAEZ,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAFF,CAArB;AAGAI,UAAAA,iBAAiB,GAAGY,YAAY,CAACX,OAAb,CAAqBb,YAArB,CAApB;;AACA,cAAIY,iBAAiB,KAAK,CAA1B,EAA6B;AAC1Bc,YAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ;AACA1B,YAAAA,YAAY,CACRqB,MADJ,CACW,CADX,EACcZ,cAAc,GAAGa,CAD/B,EAEIJ,OAFJ,CAEaJ,IAAD,IAAUpB,UAAU,CAACyB,IAAX,CAAgBL,IAAI,CAACM,EAArB,CAFtB;AAGA;AACF,WAND,MAMO,IAAIT,iBAAiB,KAAKX,YAAY,CAACU,MAAb,GAAsB,CAAhD,EAAmD;AACvDV,YAAAA,YAAY,CACRqB,MADJ,CACW,CAACZ,cAAD,GAAkBa,CAAlB,GAAsB,CADjC,EACoCb,cAAc,GAAGa,CADrD,EAEIJ,OAFJ,CAEaJ,IAAD,IAAUpB,UAAU,CAACyB,IAAX,CAAgBL,IAAI,CAACM,EAArB,CAFtB;AAGA;AACF,WALM,MAKA;AACJK,YAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACA,kBAAMC,SAAS,GAAGJ,YAAY,CAACZ,iBAAiB,GAAG,CAArB,CAA9B;AACA,kBAAMiB,SAAS,GAAGL,YAAY,CAACZ,iBAAiB,GAAG,CAArB,CAA9B;AACA,kBAAMkB,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAAShC,YAAY,GAAG4B,SAAxB,CAAjB;AACA,kBAAMK,QAAQ,GAAGF,IAAI,CAACC,GAAL,CAASH,SAAS,GAAG7B,YAArB,CAAjB;AACA,kBAAMkC,YAAY,GACfJ,QAAQ,GAAGG,QAAX,GAAsBL,SAAtB,GAAkCC,SADrC;AAEA,kBAAMM,SAAS,GAAGlC,YAAY,CAACa,IAAb,CACdC,IAAD,IAAUA,IAAI,CAACN,KAAL,KAAeyB,YADV,EAEhBb,EAFF;AAGA1B,YAAAA,UAAU,CAACyB,IAAX,CAAgBe,SAAhB;AACAlC,YAAAA,YAAY,CAACqB,MAAb,CACGrB,YAAY,CAACY,OAAb,CACGZ,YAAY,CAACa,IAAb,CAAmBC,IAAD,IAAUA,IAAI,CAACM,EAAL,KAAYc,SAAxC,CADH,CADH,EAIG,CAJH;AAMAT,YAAAA,OAAO,CAACC,GAAR,CAAYS,UAAZ;AACF;AACH;AACH;AACH;;AACD,WAAOzC,UAAP;AACF;AACH,CA5ED;;AA8EA,MAAM0C,aAAa,GAAG,CAACC,KAAK,GAAG5C,YAAT,EAAuB6C,MAAvB,KAAkC;AACrD,MAAIC,QAAJ,EAAc5C,IAAd,EAAoB6C,GAApB;;AACA,UAAQF,MAAM,CAACG,IAAf;AACG,SAAKrD,aAAL;AACGO,MAAAA,IAAI,GAAG,CAAC,GAAG0C,KAAK,CAAC1C,IAAV,CAAP;AACA4C,MAAAA,QAAQ,GAAGD,MAAM,CAACC,QAAlB;;AACA,WAAK,IAAIjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,QAAQ,CAACG,IAA7B,EAAmCpB,CAAC,EAApC,EAAwC;AACrC3B,QAAAA,IAAI,CAACwB,IAAL,CAAU,EAAV;AACF;;AACDxB,MAAAA,IAAI,CAACuB,OAAL,CAAa,CAACJ,IAAD,EAAOG,KAAP,KAAiB;AAC3B,aAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,QAAQ,CAACI,OAA7B,EAAsCrB,CAAC,EAAvC,EAA2C;AACxC,gBAAMsB,UAAU,GAAG;AAChBxB,YAAAA,EAAE,EAAEyB,MAAM,CAAC5B,KAAK,GAAG,CAAT,CAAN,CAAkBb,MAAlB,CAAyBkB,CAAC,GAAG,CAA7B,CADY;AAEhBd,YAAAA,KAAK,EAAEsB,IAAI,CAACgB,KAAL,CAAW,MAAMhB,IAAI,CAACiB,MAAL,KAAgB,GAAjC;AAFS,WAAnB;AAIAjC,UAAAA,IAAI,CAACK,IAAL,CAAUyB,UAAV;AACF;AACH,OARD;AASA,aAAO,EAAE,GAAGP,KAAL;AAAY1C,QAAAA;AAAZ,OAAP;;AACH,SAAKR,cAAL;AACGQ,MAAAA,IAAI,GAAG,CAAC,GAAG0C,KAAK,CAAC1C,IAAV,CAAP;AACAA,MAAAA,IAAI,CACAkB,IADJ,CACUmC,GAAD,IAASA,GAAG,CAACnC,IAAJ,CAAUC,IAAD,IAAUA,IAAI,CAACM,EAAL,KAAYkB,MAAM,CAAClB,EAAtC,CADlB,EAEIJ,MAFJ,CAEYF,IAAD,IAAUA,IAAI,CAACM,EAAL,KAAYkB,MAAM,CAAClB,EAFxC,EAE4C,CAF5C,EAE+CZ,KAF/C;AAGA,aAAO,EAAE,GAAG6B,KAAL;AAAY1C,QAAAA;AAAZ,OAAP;;AACH,SAAKN,UAAL;AACGM,MAAAA,IAAI,GAAG,CAAC,GAAG0C,KAAK,CAAC1C,IAAV,CAAP;AACAA,MAAAA,IAAI,CAAC0B,MAAL,CAAYiB,MAAM,CAACrB,KAAnB,EAA0B,CAA1B;AACA,aAAO,EAAE,GAAGoB,KAAL;AAAY1C,QAAAA;AAAZ,OAAP;;AACH,SAAKL,OAAL;AACGK,MAAAA,IAAI,GAAG,CAAC,GAAG0C,KAAK,CAAC1C,IAAV,CAAP;AACA,UAAIsD,MAAM,GAAG,EAAb;;AACA,WAAK,IAAI3B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,MAAM,CAACY,YAA3B,EAAyC5B,CAAC,EAA1C,EAA8C;AAC3C,cAAMsB,UAAU,GAAG;AAChBxB,UAAAA,EAAE,EAAEyB,MAAM,CAAClD,IAAI,CAACe,MAAL,GAAc,CAAf,CAAN,CAAwBN,MAAxB,CAA+BkB,CAAC,GAAG,CAAnC,CADY;AAEhBd,UAAAA,KAAK,EAAEsB,IAAI,CAACgB,KAAL,CAAW,MAAMhB,IAAI,CAACiB,MAAL,KAAgB,GAAjC;AAFS,SAAnB;AAIAE,QAAAA,MAAM,CAAC9B,IAAP,CAAYyB,UAAZ;AACF;;AACDjD,MAAAA,IAAI,CAACwB,IAAL,CAAU8B,MAAV;AACA,aAAO,EAAE,GAAGZ,KAAL;AAAY1C,QAAAA;AAAZ,OAAP;;AACH,SAAKJ,eAAL;AACGI,MAAAA,IAAI,GAAG,CAAC,GAAG0C,KAAK,CAAC1C,IAAV,CAAP;AACA,YAAMG,UAAU,GAAGwC,MAAM,CAACxC,UAA1B;AACA,YAAMC,YAAY,GAAGuC,MAAM,CAACvC,YAA5B;AACAyC,MAAAA,GAAG,GAAG5C,cAAc,CAACD,IAAD,EAAOG,UAAP,EAAmBC,YAAnB,CAApB;AACA,aAAO,EAAE,GAAGsC,KAAL;AAAY3C,QAAAA,UAAU,EAAE8C;AAAxB,OAAP;;AACH,SAAKhD,iBAAL;AACGgD,MAAAA,GAAG,GAAG,CAAC,GAAGH,KAAK,CAAC3C,UAAV,CAAN;AACA8C,MAAAA,GAAG,GAAG,EAAN;AACA,aAAO,EAAE,GAAGH,KAAL;AAAY3C,QAAAA,UAAU,EAAE8C;AAAxB,OAAP;;AACH;AACG,aAAOH,KAAP;AAlDN;AAoDF,CAtDD;;AAwDA,eAAeD,aAAf","sourcesContent":["import {\n   INCREMENT_CELL,\n   CREATE_MATRIX,\n   REMOVE_ROW,\n   ADD_ROW,\n   SET_NEAREST_IDS,\n   RESET_NEAREST_IDS,\n} from \"../types\";\n\nconst initialState = { nearestIds: [], data: [] };\n//TODO: row 1 column 3 cells 2\nconst findNearestIds = (matrixData, cellsCount, currentValue) => {\n   if (+cellsCount === 0) {\n      return [];\n   } else {\n      let sortedMatrix = matrixData\n         .reduce((currentRow, nextRow) => currentRow.concat(nextRow))\n         .sort((a, b) => a.value - b.value);\n      let nearestIds = [];\n      const iterationCount =\n         cellsCount < sortedMatrix.length\n            ? cellsCount\n            : sortedMatrix.length - 1;\n      let indexCurrentValue = sortedMatrix.indexOf(\n         sortedMatrix.find((item) => item.value === currentValue)\n      );\n      const exclusionIds = (indexCurrentValue) =>\n         sortedMatrix\n            .filter((item, index) => index !== indexCurrentValue)\n            .forEach((item) => nearestIds.push(item.id));\n      if (indexCurrentValue === 0) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentValue)\n            : sortedMatrix\n                 .splice(1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      } else if (indexCurrentValue === sortedMatrix.length - 1) {\n         sortedMatrix.length - 1 === iterationCount\n            ? exclusionIds(indexCurrentValue)\n            : sortedMatrix\n                 .splice(-iterationCount - 1, iterationCount)\n                 .forEach((item) => nearestIds.push(item.id));\n      } else {\n         if (sortedMatrix.length - 1 === iterationCount) {\n            exclusionIds(indexCurrentValue);\n         } else {\n            for (let i = 0; i < iterationCount; i++) {\n               const sortedValues = sortedMatrix\n                  .map((data) => data.value)\n                  .sort((a, b) => a - b);\n               indexCurrentValue = sortedValues.indexOf(currentValue);\n               if (indexCurrentValue === 0) {\n                  console.log('indes 0 for')\n                  sortedMatrix\n                     .splice(1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else if (indexCurrentValue === sortedMatrix.length - 1) {\n                  sortedMatrix\n                     .splice(-iterationCount - i - 1, iterationCount - i)\n                     .forEach((item) => nearestIds.push(item.id));\n                  break;\n               } else {\n                  console.log('indes  for')\n                  const prevValue = sortedValues[indexCurrentValue - 1];\n                  const nextValue = sortedValues[indexCurrentValue + 1];\n                  const prevDiff = Math.abs(currentValue - prevValue);\n                  const nextDiff = Math.abs(nextValue - currentValue);\n                  const nearestValue =\n                     prevDiff < nextDiff ? prevValue : nextValue;\n                  const nearestId = sortedMatrix.find(\n                     (item) => item.value === nearestValue\n                  ).id;\n                  nearestIds.push(nearestId);\n                  sortedMatrix.splice(\n                     sortedMatrix.indexOf(\n                        sortedMatrix.find((item) => item.id === nearestId)\n                     ),\n                     1\n                  );\n                  console.log(nearestids)\n               }\n            }\n         }\n      }\n      return nearestIds;\n   }\n};\n\nconst matrixReducer = (state = initialState, action) => {\n   let settings, data, ids;\n   switch (action.type) {\n      case CREATE_MATRIX:\n         data = [...state.data];\n         settings = action.settings;\n         for (let i = 0; i < settings.rows; i++) {\n            data.push([]);\n         }\n         data.forEach((item, index) => {\n            for (let i = 0; i < settings.columns; i++) {\n               const cellObject = {\n                  id: String(index + 1).concat(i + 1),\n                  value: Math.round(100 + Math.random() * 899),\n               };\n               item.push(cellObject);\n            }\n         });\n         return { ...state, data };\n      case INCREMENT_CELL:\n         data = [...state.data];\n         data\n            .find((row) => row.find((item) => item.id === action.id))\n            .filter((item) => item.id === action.id)[0].value++;\n         return { ...state, data };\n      case REMOVE_ROW:\n         data = [...state.data];\n         data.splice(action.index, 1);\n         return { ...state, data };\n      case ADD_ROW:\n         data = [...state.data];\n         let newRow = [];\n         for (let i = 0; i < action.columnsCount; i++) {\n            const cellObject = {\n               id: String(data.length + 1).concat(i + 1),\n               value: Math.round(100 + Math.random() * 899),\n            };\n            newRow.push(cellObject);\n         }\n         data.push(newRow);\n         return { ...state, data };\n      case SET_NEAREST_IDS:\n         data = [...state.data];\n         const cellsCount = action.cellsCount;\n         const currentValue = action.currentValue;\n         ids = findNearestIds(data, cellsCount, currentValue);\n         return { ...state, nearestIds: ids };\n      case RESET_NEAREST_IDS:\n         ids = [...state.nearestIds];\n         ids = [];\n         return { ...state, nearestIds: ids };\n      default:\n         return state;\n   }\n};\n\nexport default matrixReducer;\n"]},"metadata":{},"sourceType":"module"}